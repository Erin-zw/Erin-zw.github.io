<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Erin枫</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>来者犹可追</description>
    <pubDate>Sat, 20 Aug 2022 11:36:12 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>强化专题一（信号计算）</title>
      <link>http://example.com/2022/08/20/%E4%BF%A1%E5%8F%B7/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/</link>
      <guid>http://example.com/2022/08/20/%E4%BF%A1%E5%8F%B7/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/</guid>
      <pubDate>Sat, 20 Aug 2022 11:35:05 GMT</pubDate>
      
      
      
      
      <category domain="http://example.com/categories/%E4%BF%A1%E5%8F%B7/">信号</category>
      
      
      
      <comments>http://example.com/2022/08/20/%E4%BF%A1%E5%8F%B7/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>10M信号发生器</title>
      <link>http://example.com/2021/12/13/FPGA/10M%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/</link>
      <guid>http://example.com/2021/12/13/FPGA/10M%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/</guid>
      <pubDate>Mon, 13 Dec 2021 15:03:04 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;DDS简介&lt;/p&gt;
&lt;p&gt;DDS信号发生器采用&lt;strong&gt;直接数字频率合成&lt;/strong&gt;(Direct Digital Synthesis，简称DDS)技术，把信号发生器的频率稳定度、准确度提高到与基准频率相同的水平，并且可以在很宽的频率范围内进行精细的频率调节。采</description>
        
      
      
      
      <content:encoded><![CDATA[<p>DDS简介</p><p>DDS信号发生器采用<strong>直接数字频率合成</strong>(Direct Digital Synthesis，简称DDS)技术，把信号发生器的频率稳定度、准确度提高到与基准频率相同的水平，并且可以在很宽的频率范围内进行精细的频率调节。采用这种方法设计的信号源可工作于调制状态，可对输出电平进行调节，也可输出各种波形。</p><p>DDS原理</p><p><img src="\images\FPGA\DDS\2.png" style="zoom:50%;"></p><p>在参考频率时钟的驱动下，DDS模块开始工作；当每来一个参考时钟时，累加器就把频率控制字M与N位相位寄存器输出的值进行累加，将相加后的结果再输入到相位寄存器中，而相位寄存器就将在上一个参考时钟作用时产生的数据通过反馈的方式输送到N位累加器中。这样，在时钟的作用下，就可以不停的对频率控制字进行累加。此时，用相位累加器输出的数据就是信号的相位，这个数据作为地址在波形存储器中通过查找地址所对应的幅值表，就可以完成其从相位到幅值之间的转化。</p><p>在DDS模块中，输出频率的公式为：</p><p>根据DDS的相位寄存器的位数N，把360°平均分成2的N次方份。系统时钟代表一秒多少个频率控制字，M占据2的N次方的多少，这样算出来就是一秒多少个2的N次方。也就是多少个周期，也就是频率。</p><script type="math/tex; mode=display">f_{out} = \frac {f_c*M} {2^N} \\(f_{out}为输出信号频率，f_c为系统时钟频率，M为频率控制字，N为相位寄存器位数)\\ \Delta f = \frac {f_c} {2^N}\\(\Delta f为频率分辨率)</script><p>所谓相位控制字，可以理解为就是信号的初相。相位控制字计算公式：</p><script type="math/tex; mode=display">P_{off} = \frac {phase*(2^{N}-1)} {360°}\\(关于这里为什么要减一，是因为寄存器的范围是从0-(2^N-1)，也可以不减。只需要看P_{off}是不是直接输出值)</script><p><strong>注意点：</strong>为了使</p><p>10M信号发生器相关计算</p><p>已知系统时钟为50M，</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/FPGA/">FPGA</category>
      
      
      
      <comments>http://example.com/2021/12/13/FPGA/10M%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>测试</title>
      <link>http://example.com/2021/11/24/Matlab/Test/</link>
      <guid>http://example.com/2021/11/24/Matlab/Test/</guid>
      <pubDate>Wed, 24 Nov 2021 14:58:06 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;复数矩阵的转置、共轭、共轭转置&quot;&gt;&lt;a href=&quot;#复数矩阵的转置、共轭、共轭转置&quot; class=&quot;headerlink&quot; title=&quot;复数矩阵的转置、共轭、共轭转置&quot;&gt;&lt;/a&gt;复数矩阵的转置、共轭、共轭转置&lt;/h4&gt;&lt;p&gt;conj是共轭运算&lt;/p&gt;
&lt;scr</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="复数矩阵的转置、共轭、共轭转置"><a href="#复数矩阵的转置、共轭、共轭转置" class="headerlink" title="复数矩阵的转置、共轭、共轭转置"></a>复数矩阵的转置、共轭、共轭转置</h4><p>conj是共轭运算</p><script type="math/tex; mode=display">A = \begin{bmatrix}2+3i & 3-4i \\ 5+i & 7-2i \end{bmatrix}\ \\conj(A) = \begin{bmatrix}2-3i & 3+4i \\ 5-i & 7+2i\end{bmatrix}\ \\A.' = \begin{bmatrix}2+3i & 5+i \\ 3-4i & 7-2i \end{bmatrix}\ \\conj(A.') = A' = \begin{bmatrix}2-3i & 5-i \\ 3+4i & 7+2i \end{bmatrix}</script>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Matlab/">Matlab</category>
      
      
      
      <comments>http://example.com/2021/11/24/Matlab/Test/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>异常</title>
      <link>http://example.com/2021/11/12/Java/%E7%AC%AC%E4%BA%94%E7%AB%A0/</link>
      <guid>http://example.com/2021/11/12/Java/%E7%AC%AC%E4%BA%94%E7%AB%A0/</guid>
      <pubDate>Fri, 12 Nov 2021 13:13:33 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;异常处理基础&quot;&gt;&lt;a href=&quot;#异常处理基础&quot; class=&quot;headerlink&quot; title=&quot;异常处理基础&quot;&gt;&lt;/a&gt;异常处理基础&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;\images\Java\第五章\2.jpg&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="异常处理基础"><a href="#异常处理基础" class="headerlink" title="异常处理基础"></a>异常处理基础</h1><p><img src="\images\Java\第五章\2.jpg" style="zoom:50%;"></p><p><strong>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有些时候是可以避免的。</strong></p><p><strong>面向对象语言异常处理思想</strong>：</p><ul><li>将程序正常代码和错误处理代码分开。</li><li>使程序具有处理运行错误的能力。</li></ul><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>错误（Error）指程序运行时遇到的<strong>硬件</strong>、<strong>操作系统</strong>、 <strong>虚拟机</strong>的错误。 Error错误类</p><p><strong>Java程序不能处理错误，只能依靠外界干预。</strong></p><p><img src="\images\Java\第五章\1.jpg" style="zoom:50%;"></p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常（Exception）指在硬件、操作系统、虚拟 机正常时，<strong>程序遇到的运行错（语义错)</strong>。</p><p><img src="\images\Java\第五章\3.jpg" style="zoom:50%;"></p><p><strong>异常处理方式：</strong></p><ul><li>程序应避免而不捕获的异常，运行异常 ，除数为0、数组下标越界等</li><li>必须捕获的异常。数值格式异常，如果没有捕获，由Java虚拟机处理。文件不存在、网络连接中断、数据库连接中断等，必须捕获，否则编译不能通过。</li></ul><h1 id="异常处理措施"><a href="#异常处理措施" class="headerlink" title="异常处理措施"></a>异常处理措施</h1><h2 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>； <span class="comment">//存在潜在异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (异常类 异常对象)</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">2</span>； <span class="comment">//捕获到异常并进行处理的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">3</span>；<span class="comment">//最后必须执行的代码，无论是否捕获到异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;123a&quot;</span>; </span><br><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i = Integer.parseInt(str); <span class="comment">//调用声明抛出异常方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(NumberFormatException ex) <span class="comment">//捕获异常对象</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(str+<span class="string">&quot;字符串不能转换为整数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception ex) <span class="comment">//捕获所有异常对象</span></span><br><span class="line">&#123;</span><br><span class="line">    ex.printStackTrace(); <span class="comment">//显示异常栈跟踪信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try语句执行流程"><a href="#try语句执行流程" class="headerlink" title="try语句执行流程"></a>try语句执行流程</h2>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java/">Java</category>
      
      
      
      <comments>http://example.com/2021/11/12/Java/%E7%AC%AC%E4%BA%94%E7%AB%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>接口</title>
      <link>http://example.com/2021/11/10/Java/%E7%AC%AC%E5%9B%9B%E7%AB%A0/</link>
      <guid>http://example.com/2021/11/10/Java/%E7%AC%AC%E5%9B%9B%E7%AB%A0/</guid>
      <pubDate>Wed, 10 Nov 2021 14:45:25 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h1&gt;&lt;p&gt;接口中常量定义时，可以不写public static final，缺省有。接口中方法定义 时，可以不写public abstract，缺省有</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口中常量定义时，可以不写public static final，缺省有。接口中方法定义 时，可以不写public abstract，缺省有。接口只定义不变的内容（常量和抽象方法）</p><p>一个类可以实现多个接口（implements），接口不能new一个对象，但是是引用数据类型，并且可用于声明引用变量类型。接口可以继承另一个接口（extends），而且支持多继承。一个类实现一个接口，必须实现之中所有方法，并且方法只能是 public的</p><p><strong>定义方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="class"><span class="keyword">interface</span> 接口 [<span class="keyword">extends</span> 父接口列表 ]</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] 数据类型 成员变量=常量值;</span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">abstract</span>] 返回值类型 成员方法[(参数列表)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口声明的引用类型变量只能调用接口中定义过的方法。</strong>比如下面的ar和vol，只能调用相应的area方法和volume方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ClosedFigure fig = <span class="keyword">new</span> Ellipse(point,<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//父类对象fig引用椭圆子类实例</span></span><br><span class="line">Area ar = fig; <span class="comment">//Area接口对象ar引用实现Area接口的</span></span><br><span class="line">ClosedFigure类的Ellipse子类实例</span><br><span class="line">ar.area() <span class="comment">//运行时多态</span></span><br><span class="line">Cylinder cylinder = <span class="keyword">new</span> Cylinder(fig,<span class="number">10</span>); <span class="comment">//椭圆柱</span></span><br><span class="line">ar = cylinder; <span class="comment">//ar引用实现Area接口的Cylinder类的实例</span></span><br><span class="line">Volume vol = cylinder; <span class="comment">//Volume接口对象vol引用实现Volume接口的Cylinder类的实例</span></span><br><span class="line">ar.area() <span class="comment">//运行时多态</span></span><br><span class="line">vol.volume()</span><br></pre></td></tr></table></figure><p><img src="\imazges\Java\第四章\1.jpg" style="zoom:67%;"></p><h1 id="内部类和内部接口"><a href="#内部类和内部接口" class="headerlink" title="内部类和内部接口"></a>内部类和内部接口</h1><ul><li>内嵌类型不能与外层类型同名。</li><li>内部类中可以声明成员变量和成员方法。</li><li>内部类可以继承父类或实现接口。</li><li>可以声明内部类为抽象类，该抽象类必 须被其他内部类继承；内部接口必须被 其他内部类实现。</li><li>使用点运算符“ . ”引用内嵌类型： 外层类型.内嵌类型</li><li>内嵌类型具有类中成员的4种访问控制权限。当内 部类可被访问时，才能考虑内部类中成员的访问控 制权限</li><li>内嵌类型与其外层类型彼此信任，能访问对方的所 有成员。</li><li>在实例内部类中，使用以下格式引用或调用外部类当前实例的成员变量或实例 成员方法</li><li>内部接口总是静态的。内部类可声明是静态的或实 例的，静态内部类能够声明静态成员，但不能引用 外部类的实例成员；实例内部类不能声明静态成员</li></ul><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型声明"><a href="#泛型声明" class="headerlink" title="泛型声明"></a>泛型声明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类&lt;类型参数列表&gt; [<span class="keyword">extends</span> 父类] [<span class="keyword">implements</span> 接口列表]</span></span><br><span class="line"><span class="class">[<span class="title">public</span>] <span class="title">interface</span> 接口&lt;类型参数列表&gt; [<span class="keyword">extends</span> 父接口列表]</span></span><br><span class="line"><span class="class">[<span class="title">public</span>] [<span class="title">static</span>] &lt;类型参数列表&gt; 返回值类型 方法([参数列表]) [<span class="title">throws</span> 异常类列表]</span></span><br><span class="line"><span class="class">[修饰符] <span class="title">class</span> 类&lt;类型参数列表&gt;[<span class="keyword">extends</span> 父类] [<span class="keyword">implements</span> 接口列表]</span></span><br><span class="line"><span class="class">[<span class="title">public</span>] <span class="title">interface</span> 接口&lt;类型参数列表&gt;[<span class="keyword">extends</span> 父接口列表]</span></span><br><span class="line"><span class="class">[<span class="title">public</span>] [<span class="title">static</span>] &lt;类型参数列表&gt; 返回值类型 方法([参数列表]) [<span class="title">throws</span> 异常类列表]</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java/">Java</category>
      
      
      
      <comments>http://example.com/2021/11/10/Java/%E7%AC%AC%E5%9B%9B%E7%AB%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>类</title>
      <link>http://example.com/2021/11/08/Java/%E7%AC%AC%E4%B8%89%E7%AB%A0/</link>
      <guid>http://example.com/2021/11/08/Java/%E7%AC%AC%E4%B8%89%E7%AB%A0/</guid>
      <pubDate>Mon, 08 Nov 2021 11:41:16 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h1&gt;&lt;p&gt;类相当于是对象的模板，可以认为对象就是实例。&lt;/p&gt;
&lt;p&gt;也可以像下面这样理解？&lt;/p&gt;
&lt;figure class=&quot;h</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类相当于是对象的模板，可以认为对象就是实例。</p><p>也可以像下面这样理解？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类 对象;<span class="comment">//这里的相当于对象</span></span><br><span class="line">对象 = <span class="keyword">new</span> 类的构造方法([参数列表]);<span class="comment">//分配了内存空间以后才是一个实例</span></span><br></pre></td></tr></table></figure><p><strong>类（class）</strong>是既包括数据又包括作用于数据的一组操作的 封装体。类可以看成是一类相似对象的模板！类具有封装性、 继承性、多态性和抽象性。</p><p><strong>对象（object）</strong>是类的具体<strong>实例（instance）</strong>。Java中， 万事万物皆对象！！！Java中通过引用操作对象！引用就 是指向对象的内存中地址！！</p><h1 id="类的变量和方法"><a href="#类的变量和方法" class="headerlink" title="类的变量和方法"></a>类的变量和方法</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>在类中，用static声明的成员变量为静态成员变量，它为该类的公用变量、属于类，被 该类的所有实例共享，在类被载入时被显示初始化；对于该类的所有对象来说，static成员变量只有一份；可以使用 “对象.类属性”来调用，不过，一般都是用”类名.类属性”；static变量置于方法区中）。<strong>局部变量</strong>使用前必须要<strong>先赋值</strong>、而<strong>实例变量</strong>则有<strong>缺省初值</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">22</span>;<span class="comment">//类变量</span></span><br><span class="line">    String name = <span class="string">&quot;张三&quot;</span>;<span class="comment">//实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>局部变量：</strong></p><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li><strong>访问修饰符不能用于局部变量；</strong></li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul><p><strong>实例变量：</strong></p><ul><li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>访问修饰符可以修饰实例变量；</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li></ul><p><strong>类变量(静态变量)：</strong></p><ul><li>类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。</li><li>无论一个类创建了多少个对象，<strong>类只拥有类变量的一份拷贝。</strong></li><li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li><li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li><li>静态变量在程序开始时创建，在程序结束时销毁。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li><li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li><li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>定义格式：<code>[修饰符] 方法返回值类型 方法名(形参列表) &#123; // n条语句 &#125;</code></p><h1 id="类的封装性"><a href="#类的封装性" class="headerlink" title="类的封装性"></a>类的封装性</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法，又称为<strong>构造器Constructor</strong>，用于构造该类的实例。<strong>返回值类型</strong>为该类本身。</p><p>如果我们没有定义构造器，系统自动会定义一个无参的构造器，如果已定义则编译器不会添加；构造器的方法名必须和类名一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明及调用构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> </span></span><br><span class="line"><span class="class"></span>&#123; <span class="function"><span class="keyword">public</span> <span class="title">MyDate</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        year = y;</span><br><span class="line">        month = m;</span><br><span class="line">        day = d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyDate d = <span class="keyword">new</span> MyDate(<span class="number">2009</span>,<span class="number">7</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyDate</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>方法的<strong>重载</strong>overload。方法的重载是指一个类中可以定义有相同的名字， 但参数不同的多个方法。调用时，会根据不同的参数列表选择对应的方法。</p><p><strong>重载</strong>：同一个类，同一个方法名，不同的参数列表（类型、个数、顺序不同）</p><ul><li><p>只有返回值不同不构成方法的重载。 </p></li><li><p>只有形参的名称不同，不构成方法的重载。</p></li><li><p>构造方法与普通方法一样也可以重载。</p></li></ul><h2 id="对象的引用和运算"><a href="#对象的引用和运算" class="headerlink" title="对象的引用和运算"></a>对象的引用和运算</h2><h3 id="this引用"><a href="#this引用" class="headerlink" title="this引用"></a>this引用</h3><ul><li>指代对象本身</li><li>访问本类的成员变量和成员方法</li><li>调用<strong>本类重载的构造方法</strong></li><li>普通方法中，this总是指向调用该方法的对象；</li><li>构造方法中，this总是指向正要初始化的对象；</li><li>this<strong>不能用于static</strong>方法；</li><li>可以在一个构造方法中通过this调用其它构造方法，且<strong>必须是构造方法中的第一条语句</strong>。</li><li>this只能用在方法中，其的本质是“<strong>调用该方法的创建好的对象的地址</strong>”。由于在 构造方法调用时，对象已经创建。因此，在构造方法中也可以使用this代表“当前 对象”。</li></ul><h3 id="instanceof运算"><a href="#instanceof运算" class="headerlink" title="instanceof运算"></a>instanceof运算</h3><p>instanceof 运算符 用于：判断 该运算符前面引用类型变量指向的对象是否是后面类，或者其子类、接口实现类创建的对象。如果是则返回true，否则返回false</p><h2 id="隐藏-封装"><a href="#隐藏-封装" class="headerlink" title="隐藏/封装"></a>隐藏/封装</h2><p><strong>类的访问权限：</strong>public和缺省</p><p><strong>类中成员的访问权限：</strong></p><div class="table-container"><table><thead><tr><th>权限修饰符</th><th>同一类</th><th>同一包</th><th>不同包的子类</th><th>所有类</th></tr></thead><tbody><tr><td>public(公有)</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected(受保护的)</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>缺省</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>private(私有)</td><td>√</td><td></td><td></td></tr></tbody></table></div><p><strong>静态成员变量：</strong>在类中，用static声明的成员变量为静态成员变量，或叫做类属 性、类变量。它为该类的公用变量，属于类，被该类的所有实例共享（只此一 份），在类被载入时被显式初始化。可以使用“对象.类属性”来调用，不过一般 都使用“类名.类属性”。static变量置于方法区</p><p><strong>静态方法：</strong></p><ul><li><p>静态方法不需要通过它所属的类的任何实例就可以被调用，因此在静态方法中不能使用 this 关键字，也不能直接访问所属类的实例变量和实例方法，但是可以直接访问所属类的静态变量和静态方法。另外，和 this  关键字一样，super 关键字也与类的特定实例相关，所以在静态方法中也不能使用 super 关键字。父类中是静态方法，</p></li><li><p>子类中不能覆盖为非静态方法；在符合覆盖规则的前提下， 在父子类中，父类中的静态方法可以被子类中的静态方法覆盖，但无多态</p></li><li>父子类中，静态方法只能被静态方法覆盖，父子类中，非静态方法只能被非静态方法覆盖</li></ul><p><strong>静态初始化块 static {}：</strong>如果希望加载后，对整个类进行某些初始化操作，可 以使用static初始化，</p><ul><li>是在类初始化时执行，不是在创建对象时执行。</li><li>静态初始化块中不能访问非static成员变量。</li><li>执行顺序：上溯到Object类，先执行Object的静态初始化块，再向下执行子 类的静态初始化块，直到我们的类的静态初始化块为止。</li></ul><h1 id="类的继承性"><a href="#类的继承性" class="headerlink" title="类的继承性"></a>类的继承性</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>基于一个已存在的类，创建一个新的类。已存在的类即父类，新的类即子类，继承就是子类继承并拥有父类的属性和方法，同时，子类还有拥有父类所不具有的属性和方法。</p><p>父类，也称为基类、超类（superclass）；子类，也称为派生类。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul><li>子类继承父类的成员变量</li><li>子类继承父类除构造方法以外的成员方法</li><li>子类不能继承父类的构造方法</li><li>子类可以增加成员，可以重定义从父类继承来的 成员，但不能删除它们。</li></ul><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Object</span><span class="params">()</span> <span class="comment">//构造方法</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> <span class="comment">//描述对象</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//比较对象相等</span></span></span><br><span class="line"><span class="function">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>Java中的类都是Object的子类</p><h2 id="子类对父类成员的访问权限"><a href="#子类对父类成员的访问权限" class="headerlink" title="子类对父类成员的访问权限"></a>子类对父类成员的访问权限</h2><ul><li>子类不能访问父类的私有成员（private）</li><li>子类能够访问父类的公有成员（public）和保护成员（protected）。</li><li>子类对父类的缺省权限成员的访问控制，以包为界分两种情况，可以访问当前包中成员</li></ul><h2 id="子类的构造方法"><a href="#子类的构造方法" class="headerlink" title="子类的构造方法"></a>子类的构造方法</h2><p>使用super()调用父类构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>([参数列表])</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, MyDate birthday, String spec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, birthday); <span class="comment">//调用父类同参数的构造方法</span></span><br><span class="line">    <span class="keyword">this</span>.speciality = spec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认执行super()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> <span class="comment">//Java提供的默认构造方法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">//调用父类构造方法Person()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="super引用"><a href="#super引用" class="headerlink" title="super引用"></a>super引用</h2><ul><li>调用父类的构造方法。<code>super([参数列表])</code></li><li>引用父类同名成员。<code>super.成员变量</code>，<code>super.成员方法([参数列表])</code></li><li>super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方 法或属性。</li></ul><h1 id="类的抽象性"><a href="#类的抽象性" class="headerlink" title="类的抽象性"></a>类的抽象性</h1><ul><li>有抽象方法的类只能定义成抽象类。</li><li>抽象类不能实例化，即不能用new来实例化抽象类。</li><li>抽象类只能用来继承。</li><li>抽象类可以包含属性、方法、构造方法（抽象类除了抽象方法，也可以定义普通方法、 构造方法和普通属性）。但是构造方法不能用来new实例，只能用来被子类调用。</li><li>抽象方法只有方法的声明，没有方法体（即{}和里面的代码），其必须被子类实现 （这也是抽象方法的设计初衷，提供规范，要求各子类实现规范）</li><li>抽象类用于设计和实现的分离，但是这种分离不够彻底。</li><li>一个抽象类可以继承另一个抽象类</li><li>有抽象方法的类一定是抽象类，但是抽象类中不一定都是抽象方法，也可以全部都是具体方法</li></ul><p><strong>特点：</strong></p><ul><li>构造方法、静态成员方法不能被声明为抽象方法。</li><li>一个非抽象类必须实现从父类继承来的所有抽象方法</li><li>不能创建抽象类的实例。</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java/">Java</category>
      
      
      
      <comments>http://example.com/2021/11/08/Java/%E7%AC%AC%E4%B8%89%E7%AB%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>parameter,defparame,`define,localparam四者区别</title>
      <link>http://example.com/2021/11/07/FPGA/parameter/</link>
      <guid>http://example.com/2021/11/07/FPGA/parameter/</guid>
      <pubDate>Sun, 07 Nov 2021 09:02:40 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;figure class=&quot;highlight verilog&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span>:    作用 -&gt; 常用于定义常量可以跨模块、跨文件;</span></span><br><span class="line">            范围 -&gt; 整个工程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span>:  作用 -&gt; 常用于模块间参数传递;</span><br><span class="line">            范围 -&gt; 本<span class="keyword">module</span>内有效的定义;</span><br><span class="line"></span><br><span class="line"><span class="keyword">localparam</span>: 作用 -&gt; 常用于状态机的参数定义;</span><br><span class="line">            范围 -&gt; 本<span class="keyword">module</span>内有效的定义，不可用于参数传递;</span><br><span class="line"><span class="keyword">localparam</span> cannot be used <span class="keyword">within</span> the <span class="keyword">module</span> port <span class="keyword">parameter</span> list.</span><br></pre></td></tr></table></figure><h2 id="Parameter"><a href="#Parameter" class="headerlink" title="Parameter"></a>Parameter</h2><p>可以放在模块头上也可以放在模块的内部，他可以通过defparameter的方式或者模块实例化的时候进行重写。</p><p><strong>Example：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo</span><br><span class="line">#(<span class="keyword">parameter</span> MSB=<span class="number">3</span>, LSB=<span class="number">0</span>, DEPTH=<span class="number">4</span>)<span class="comment">//可以被重写</span></span><br><span class="line"> (port_list );</span><br><span class="line"> item;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo</span><br><span class="line"> (port_list );</span><br><span class="line"> <span class="keyword">parameter</span> MSB=<span class="number">3</span>, LSB=<span class="number">0</span>, DEPTH=<span class="number">4</span><span class="comment">//可以被重写</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>一旦有模块参数被写在模块头部，则出现在模块内部的模块参数被视为本地参数，不能被重写。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo</span><br><span class="line"> #(<span class="keyword">parameter</span> MSB=<span class="number">3</span>, LSB=<span class="number">0</span>)<span class="comment">//可以被重写</span></span><br><span class="line"> (port_list );</span><br><span class="line"><span class="keyword">parameter</span> DEPTH=<span class="number">4</span>; <span class="comment">//不能被重写</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>在上层模块对参数重写的方式如下:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)F1<span class="variable">.MSB</span>=<span class="number">4</span>;F1<span class="variable">.LSB</span>=<span class="number">2</span>;fifo F1;</span><br><span class="line"><span class="number">2</span>) fifo <span class="variable">#(4,2) F1(port_list)</span>;</span><br><span class="line"><span class="number">3</span>) fifo <span class="variable">#(.LSB(2), .MSB(4)) fifo(port_list)</span>;</span><br></pre></td></tr></table></figure><h2 id="defparam修改参数"><a href="#defparam修改参数" class="headerlink" title="defparam修改参数"></a>defparam修改参数</h2><p>当一个模块引用另外一个模块时，高层模块可以改变低层模块用parameter定义的参数值。例子代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Top(...);<span class="comment">//这是一个顶层模块</span></span><br><span class="line">    <span class="keyword">defparam</span>    U_D1<span class="variable">.Width</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">defparam</span>    U_D1<span class="variable">.Polarity</span> = <span class="number">0</span>;<span class="comment">//使得U_D1的Width = 4， Polarity = 0；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defparam</span>    U_D2<span class="variable">.Width</span> = <span class="number">5</span>;<span class="comment">//使得U_D2的Width = 5，Polarity 不变，即为1；</span></span><br><span class="line">    Decode U_D1();</span><br><span class="line">    Decode U_D2(); </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Decode(A,F);    <span class="comment">//这是一个子模块</span></span><br><span class="line">    <span class="keyword">parameter</span> Width = <span class="number">1</span>, Polarity = <span class="number">1</span>;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>也可以模块实例化的时候进行修改，代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Top(...);<span class="comment">//这是一个顶层模块</span></span><br><span class="line">    Decode <span class="variable">#(4,0) U_D1()</span>; <span class="comment">//使得Width = 4， Polarity = 0；</span></span><br><span class="line">    Decode <span class="variable">#(5) U_D2()</span>; <span class="comment">//使得 Width = 5，Polarity 不变，即为1；</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Decode(A,F);    <span class="comment">//这是一个子模块</span></span><br><span class="line">    <span class="keyword">parameter</span> Width = <span class="number">1</span>, Polarity = <span class="number">1</span>;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="define"><a href="#define" class="headerlink" title="`define"></a>`define</h2><p><strong>概念：</strong>可以跨模块的定义，写在模块名称上面，在整个设计工程都有效。一旦define指令被编译，其在整个编译过程中都有效。例如，通<br>过另一个文件中的define指令，定义的常量可以被其他文件调用,直到遇到undef；</p><p><strong>举例：</strong>定义 define UART_CNT 10’d1024.使用UART_CNT</p><h2 id="localparam："><a href="#localparam：" class="headerlink" title="localparam："></a>localparam：</h2><p><strong>概念：</strong>本module内有效的定义，不可用于参数传递；localparamcannot be used within the module port parameter list.一般情况下，状态机的参数都是用localparam的。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/FPGA/">FPGA</category>
      
      
      
      <comments>http://example.com/2021/11/07/FPGA/parameter/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>时域卷积频域相乘</title>
      <link>http://example.com/2021/11/07/%E4%BF%A1%E5%8F%B7/%E6%97%B6%E5%9F%9F%E5%8D%B7%E7%A7%AF%E9%A2%91%E5%9F%9F%E7%9B%B8%E4%B9%98/</link>
      <guid>http://example.com/2021/11/07/%E4%BF%A1%E5%8F%B7/%E6%97%B6%E5%9F%9F%E5%8D%B7%E7%A7%AF%E9%A2%91%E5%9F%9F%E7%9B%B8%E4%B9%98/</guid>
      <pubDate>Sun, 07 Nov 2021 07:33:57 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;傅里叶级数（时域卷积频域相乘）&lt;/p&gt;
&lt;p&gt;​    一般教科书都是选择理论证明，但是如何直观去理解呢。我们知道一个信号可以傅里叶变换分解后然后变成很多个不同频率正弦信号。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f(t)=\</description>
        
      
      
      
      <content:encoded><![CDATA[<p>傅里叶级数（时域卷积频域相乘）</p><p>​    一般教科书都是选择理论证明，但是如何直观去理解呢。我们知道一个信号可以傅里叶变换分解后然后变成很多个不同频率正弦信号。</p><script type="math/tex; mode=display">f(t)=\frac {a_0} {2} +\sum_{n=1}^{+\infty}a_ncos(n\omega_0 t)+b_nsin(n\omega_0 t)\\a_0 =\frac{1}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}}f(t)dt \ \ \ \ \ a_n = \frac{2}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(t)cos(n\omega_0t)dt\ \ \ \ \b_n = \frac{2}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(t)sin(n\omega_0t)dt</script><p>我们将两个信号去卷积，正弦信号卷积分配，不同频率的正弦信号卷积后为0（“正交”）.</p><p>那么就是相同频率的正弦信号相卷积，频率不变，辐值相乘。</p><p>而频域就是不同频率分量的相对大小，因此这在频域上就表现为相乘。</p><p>​    从知乎上看到的，写的很好，分享一下</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E4%BF%A1%E5%8F%B7/">信号</category>
      
      
      
      <comments>http://example.com/2021/11/07/%E4%BF%A1%E5%8F%B7/%E6%97%B6%E5%9F%9F%E5%8D%B7%E7%A7%AF%E9%A2%91%E5%9F%9F%E7%9B%B8%E4%B9%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Testbench文件编写方法</title>
      <link>http://example.com/2021/11/07/FPGA/Testbench%E6%96%87%E4%BB%B6%E8%AF%BB%E6%B3%95%E5%92%8C%E5%86%99%E6%B3%95/</link>
      <guid>http://example.com/2021/11/07/FPGA/Testbench%E6%96%87%E4%BB%B6%E8%AF%BB%E6%B3%95%E5%92%8C%E5%86%99%E6%B3%95/</guid>
      <pubDate>Sun, 07 Nov 2021 07:22:45 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;转载：&lt;a href=&quot;https://blog.csdn.net/weixin_46423500/article/details/113264878&quot;&gt;https://blog.csdn.net/weixin_46423500/article/details/113264</description>
        
      
      
      
      <content:encoded><![CDATA[<p>转载：<a href="https://blog.csdn.net/weixin_46423500/article/details/113264878">https://blog.csdn.net/weixin_46423500/article/details/113264878</a></p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>testbench文件基本结构：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 仿真单位/仿真精度</span></span><br><span class="line"><span class="keyword">module</span> test_bench();</span><br><span class="line"><span class="comment">//通常 testbench没有输入与输出端口</span></span><br><span class="line">信号或变量定义声明</span><br><span class="line">使用<span class="keyword">initial</span>或<span class="keyword">always</span>语句产生激励波形</span><br><span class="line">例化设计模块</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="声明仿真精度和仿真单位"><a href="#声明仿真精度和仿真单位" class="headerlink" title="声明仿真精度和仿真单位"></a>声明仿真精度和仿真单位</h3><p>/#(延时时间)，#(10ns)代表延时10ns</p><p>仿真精度就是说最低的延时精度，比如说<code>`timescale 1ns/1ns</code>，延时精度只能达到1ns</p><p>如果想要延时10.001ns，就要把仿真精度改成1ps(1ns = 1000ps)。</p><h3 id="定义模块名"><a href="#定义模块名" class="headerlink" title="定义模块名"></a>定义模块名</h3><p><code>module flow_led_tb();</code></p><p>模块名的命名方式一般在被测模块名后面加上“ _ tb”，或者在被测模块名前面加上“tb_”，表示为哪个模块提供激励测试文件，通常激励文件不需要定义输入和输出端口。</p><h3 id="信号或常量定义"><a href="#信号或常量定义" class="headerlink" title="信号或常量定义"></a>信号或常量定义</h3><p><strong>常量：</strong></p><p> 代码中定义的常量有时需要频繁的修改，为了方便修改，可以把常量定义成参数的形式，定义参数的关键字为parameter，代码如下：</p><p><code>parameter T = 20;</code></p><p><strong>变量：</strong></p><p>Verilog代码中，常用声明信号或变量的关键字为reg和wire，在initial语句或者always语句中使用的变量定义成reg类型，在assign语句或者用于连接被例化模块名的信号定义成wire类型，声明方法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reg define</span></span><br><span class="line"><span class="keyword">reg</span> sys_clk; <span class="comment">// 时钟信号</span></span><br><span class="line"><span class="keyword">reg</span> sys_rst_n; <span class="comment">// 复位信号</span></span><br><span class="line"><span class="comment">//wire define</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] led;</span><br></pre></td></tr></table></figure><p><strong>使用initial或always语句产生激励波形：</strong><br> 产生时钟激励。代码表示每10ns（假设仿真单位是1ns），sys_clk的电平状态翻转一次，由于一个完整的时钟周期包括一个高电平和一个低电平，因此sys_clk的时钟周期为20ns，占空比为50%。代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> #<span class="number">10</span> sys_clk = ~sys_clk;</span><br></pre></td></tr></table></figure><p>如果要生成其它占空比时钟的话，代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">#<span class="number">6</span> sys_clk = <span class="number">0</span>; #<span class="number">4</span> sys_clk = <span class="number">1</span>; <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在always语句中设置了sys_clk的时钟周期，并没有设置初始值，因此sys_clk需要在initial语句中进行初始化。代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"> sys_clk = <span class="number">1&#x27;b0</span>; <span class="comment">// 时钟初始值</span></span><br><span class="line">sys_rst_n = <span class="number">1&#x27;b0</span>; <span class="comment">// 复位初始值</span></span><br><span class="line"> #<span class="number">20</span> sys_rst_n = <span class="number">1&#x27;b1</span>; <span class="comment">// 在第21ns的时候复位信号信号拉高</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="例化设计模块"><a href="#例化设计模块" class="headerlink" title="例化设计模块"></a>例化设计模块</h3><p>例化的设计模块是指被测模块，例化被测模块的目的是把被测模块和激励模块实例化起来，并且把被测模块的端口与激励模块的端口进行相应的连接，使得激励可以输入到被测模块。如果被测模块是由多个模块组成的，激励模块中只需要例化多个模块的顶层模块，代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow_led u0_flow_led (</span><br><span class="line"> <span class="variable">.sys_clk</span> (sys_clk ),</span><br><span class="line"> <span class="variable">.sys_rst_n</span> (sys_rst_n),</span><br><span class="line"> <span class="variable">.led</span> (led )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="完整文件"><a href="#完整文件" class="headerlink" title="完整文件"></a>完整文件</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">`<span class="meta-keyword">timescale</span> 1ns/1ns // 定义仿真时间单位1ns和仿真时间精度为1ns</span></span><br><span class="line"> <span class="keyword">module</span> flow_led_tb(); <span class="comment">// 测试模块</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//parameter define</span></span><br><span class="line"><span class="keyword">parameter</span> T = <span class="number">20</span>; <span class="comment">// 时钟周期为20ns</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//reg define</span></span><br><span class="line"><span class="keyword">reg</span> sys_clk; <span class="comment">// 时钟信号</span></span><br><span class="line"> <span class="keyword">reg</span> sys_rst_n; <span class="comment">// 复位信号</span></span><br><span class="line"><span class="comment">//wire define</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] led;</span><br><span class="line"><span class="comment">//给输入信号初始值</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">sys_clk = <span class="number">1&#x27;b0</span>;</span><br><span class="line">sys_rst_n = <span class="number">1&#x27;b0</span>; <span class="comment">// 复位</span></span><br><span class="line"><span class="variable">#(T+1)</span> sys_rst_n = <span class="number">1&#x27;b1</span>; <span class="comment">// 在第21ns的时候复位信号信号拉高</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//50Mhz的时钟，周期则为1/50Mhz=20ns,所以每10ns，电平取反一次</span></span><br><span class="line"><span class="keyword">always</span> <span class="variable">#(T/2)</span> sys_clk = ~sys_clk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例化flow_led模块</span></span><br><span class="line">flow_led u0_flow_led (</span><br><span class="line"><span class="variable">.sys_clk</span> (sys_clk ),</span><br><span class="line"><span class="variable">.sys_rst_n</span> (sys_rst_n),</span><br><span class="line"><span class="variable">.led</span> (led )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/FPGA/">FPGA</category>
      
      
      
      <comments>http://example.com/2021/11/07/FPGA/Testbench%E6%96%87%E4%BB%B6%E8%AF%BB%E6%B3%95%E5%92%8C%E5%86%99%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>第二章</title>
      <link>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</link>
      <guid>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</guid>
      <pubDate>Fri, 05 Nov 2021 13:35:49 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;语言成分&quot;&gt;&lt;a href=&quot;#语言成分&quot; class=&quot;headerlink&quot; title=&quot;语言成分&quot;&gt;&lt;/a&gt;语言成分&lt;/h1&gt;&lt;h2 id=&quot;关键字和标识符&quot;&gt;&lt;a href=&quot;#关键字和标识符&quot; class=&quot;headerlink&quot; title=&quot;关键字</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="语言成分"><a href="#语言成分" class="headerlink" title="语言成分"></a>语言成分</h1><h2 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h2><p><strong>关键字</strong>略。</p><p><strong>标识符命名规则</strong>：</p><ol><li>标识符必须以字母、下划线_ 、美元符$开头。</li><li>标识符其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合。</li><li>Java 标识符大小写敏感，且长度无限制。</li><li>不可以是Java的关键字。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">合法的标识符：</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> _123 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> $12aa = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> 变量<span class="number">1</span> = <span class="number">55</span>;</span><br><span class="line">不合法的标识符：</span><br><span class="line"><span class="keyword">int</span> 1a = <span class="number">3</span>; <span class="comment">//不能用数字开头</span></span><br><span class="line"><span class="keyword">int</span> a# = <span class="number">3</span>; <span class="comment">//不能包含#这样的特殊字符</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">int</span> = <span class="number">3</span>; <span class="comment">//不能使用关键字</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="\images\Java\第二章\1.jpg" style="zoom:67%;"></p><p><strong>注意：</strong><code>float f = 1.1;</code>是错误的，因为float类型要加上f或F后缀，不加默认就是double型。</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p><strong>数组(Array),类(class),接口(interface)。</strong></p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>,<span class="keyword">short</span>,<span class="keyword">char</span>—&gt; <span class="keyword">int</span> —&gt; <span class="keyword">long</span>—&gt; <span class="keyword">float</span> —&gt; <span class="keyword">double</span> </span><br><span class="line"><span class="comment">//容量从高到低。</span></span><br></pre></td></tr></table></figure><p><strong>转换规则：</strong></p><ul><li>不能对boolean类型进行类型转换。</li><li>不能把对象类型转换成不相关类的对象。</li><li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li><li>转换过程中可能导致溢出或损失精度，如<code>int i =128;   byte b = (byte)i;</code>，byte类型最大127，此时b为-128.</li><li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入</li></ul><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Java是一种强类型语言，每个变量都必须声明其类型。</p><p><strong>变量类型划分：</strong></p><ol><li><strong>局部</strong>变量：方法或语句块内部定义的变量。生命周期是 从声明位置开始到”}”为止。在使用前必须先声明和初始化（赋初值）</li><li><strong>实例</strong>变量：<strong>方法外部</strong>、<strong>类的内部</strong>定义的变 量。从属于对象，生命周期伴随对象始终。如果不自行初始化，他会自动初始化成该类型的默认初始值（数值型变量初始化成0或0.0，字符型变量的初 始化值是16位的0，布尔型默认是false）</li><li><strong>静态</strong>变量：使用static定义。 从属于类，生命周期伴随类始终，从类加载到卸载。如果不自行初始化，他会自动初始化成该类型的默认初始值（数值型变量初始化成0或0.0，字符型变量的初始化值是16位的0，布尔型默认是false）</li></ol><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>定义：<code>public static final double PI = 3.14;</code></p><p>其值无法改变，只能被初始化一次。常量的命名通常使用全大写，如果单词较多则使用下划线进行分隔。</p><h2 id="一些运算符"><a href="#一些运算符" class="headerlink" title="一些运算符"></a>一些运算符</h2><p><strong>&lt;&lt;：</strong>左移运算符（丢弃最高位，0补最低位）</p><p><strong>>&gt;：</strong>右移运算符（符号位不变，左边补上符号位）</p><p><strong>>&gt;&gt;：</strong>无符号移位运算符（无符号右移、忽略符号位扩展、0补最高位。无符号右移中的符号位也跟着变，<strong>无符号的意思是将符号位当作数字位看待</strong>。）</p><p>右移一位相当于除2取商。左移 一位相当于乘2。</p><h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><p>略</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组为引用数据类型。相当于有一个指针值着吧。</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p><strong>定义方法</strong>:<code>int x[] = new int[5];</code>或者<code>int x[]; x = new int[5];</code>或者<code>int x[] = &#123;1, 2, 3, 4, 5&#125;;</code></p><p><img src="\images\Java\第二章\2.jpg" style="zoom:67%;"></p><p><strong>for语句遍历：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (类型 变量 : 数组)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> value : fib)<span class="comment">//类似py迭代器</span></span><br><span class="line"><span class="comment">//vaue获得fib数组每个元素，</span></span><br><span class="line"><span class="comment">//相当于fib[i]</span></span><br><span class="line">System.out.print(<span class="string">&quot; &quot;</span>+value);</span><br></pre></td></tr></table></figure><p>关于<strong>引用数据类型</strong>这一说：</p><p><img src="\images\Java\第二章\3.jpg" style="zoom:50%;"></p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><strong>定义方法：</strong><code>int mat[][] = new int[3][4];或者int mat[][] = &#123; &#123;1,2,3&#125;,&#123;4,5,6&#125; &#125;</code></p><p><img src="\images\Java\第二章\4.jpg" style="zoom:50%;"></p><p><img src="\images\Java\第二章\5.jpg" style="zoom:50%;"></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本定义方法</span></span><br><span class="line">[修饰符…] 返回值类型 方法名([参数列表])</span><br><span class="line">&#123;</span><br><span class="line">语句序列;</span><br><span class="line">[<span class="keyword">return</span> [返回值]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><img src="\images\Java\第二章\6.jpg" style="zoom:50%;"></p><p><strong>引用模型：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">        String s2 = s1;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(s1);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s2.equals(s1));</span><br><span class="line">        System.out.println(s1 == s3);</span><br><span class="line">        System.out.println(s3.equals(s1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#输出</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java/">Java</category>
      
      
      
      <comments>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%BA%8C%E7%AB%A0/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
