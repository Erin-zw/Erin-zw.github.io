<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Erin枫</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>来者犹可追</description>
    <pubDate>Tue, 28 May 2024 11:50:30 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>从前序与中序遍历序列构造二叉树</title>
      <link>http://example.com/2024/05/28/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <guid>http://example.com/2024/05/28/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <pubDate>Tue, 28 May 2024 08:59:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;给定两个整数数组 &lt;code&gt;preorder&lt;/code&gt; 和 &lt;code&gt;inorder&lt;/code&gt; ，其中
&lt;code&gt;preorder&lt;/code&gt; 是二叉树的&lt;strong&gt;先序遍历&lt;/strong&gt;，
&lt;code&gt;inorder&lt;/code&gt;
是同一棵树</description>
        
      
      
      
      <content:encoded><![CDATA[<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中<code>preorder</code> 是二叉树的<strong>先序遍历</strong>，<code>inorder</code>是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><h3 id="使用递归">使用递归</h3><p>这里递归的要点就是发现两种遍历的分组规律</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="comment">//[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</span></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="comment">//[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">myBuildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preorder_left, <span class="keyword">int</span> preorder_right, <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">        <span class="keyword">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">        <span class="keyword">int</span> inorder_root = indexMap.get(preorder[preorder_root]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把根节点建立出来</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preorder_root]);</span><br><span class="line">        <span class="comment">// 得到左子树中的节点数目</span></span><br><span class="line">        <span class="keyword">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        <span class="comment">// 递归地构造左子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span></span><br><span class="line">        root.left = myBuildTree(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归地构造右子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length;</span><br><span class="line">        <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myBuildTree(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sota递归">SOTA递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, inorder, Integer.MIN_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> stop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt;= preorder.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == stop)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[p++]);</span><br><span class="line">        node.left = build(preorder, inorder, node.val);</span><br><span class="line">        node.right = build(preorder, inorder, stop);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用迭代">使用迭代</h3><p>比较难想，这题建议使用递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">int</span> inorderIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> preorderVal = preorder[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inorderIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/hot-%E4%BA%8C%E5%8F%89%E6%A0%91/">hot/二叉树</category>
      
      
      
      <comments>http://example.com/2024/05/28/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>where和argwhere</title>
      <link>http://example.com/2024/05/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/where%E5%92%8Cargwhere/</link>
      <guid>http://example.com/2024/05/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/where%E5%92%8Cargwhere/</guid>
      <pubDate>Tue, 28 May 2024 06:31:24 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;where&quot;&gt;where&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第一种： np.where(condition)&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="where">where</h3><p><strong>第一种： np.where(condition)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 gt2D 是一个二维数组</span></span><br><span class="line">gt2D = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                 [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                 [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 np.where 查找大于 0 的元素的索引</span></span><br><span class="line">y_indices, x_indices = np.where(gt2D &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;行索引：&quot;</span>, y_indices)  <span class="comment"># 输出 [0 1 1 1 2]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;列索引：&quot;</span>, x_indices)  <span class="comment"># 输出 [1 0 2 1 1]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.where(gt2D &gt; <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">行索引： [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">列索引： [<span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">(array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], dtype=int64), array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>], dtype=int64))</span><br></pre></td></tr></table></figure><p><strong>第二种：np.where(condition, x, y)</strong></p><p>满足条件(condition)，输出x，不满足输出y</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 gt2D 是一个二维数组</span></span><br><span class="line">gt2D = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                 [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                 [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.where(gt2D &gt; <span class="number">0</span>, <span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">[[<span class="number">4</span> <span class="number">8</span> <span class="number">8</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">4</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">8</span> <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><h3 id="argwhere">argwhere</h3><p>用于查找满足条件的元素的索引，返回一个二维数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 gt2D 是一个二维数组</span></span><br><span class="line">gt2D = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                 [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                 [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.argwhere(gt2D &gt; <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">1</span>]]</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      
      <comments>http://example.com/2024/05/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/where%E5%92%8Cargwhere/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微调流程</title>
      <link>http://example.com/2024/05/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/SAM/%E5%BE%AE%E8%B0%83%E6%B5%81%E7%A8%8B/</link>
      <guid>http://example.com/2024/05/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/SAM/%E5%BE%AE%E8%B0%83%E6%B5%81%E7%A8%8B/</guid>
      <pubDate>Mon, 27 May 2024 12:25:30 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;流程伪代码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>流程伪代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义和预处理之后的数据集打包成npz方便使用。有很多预处理数据集的方法，我这种是将图像的编码embedding，GT，图像名称作为图像信息存在了npz</span></span><br><span class="line"><span class="comment"># 你当然可以采用自己的构建Dataset的方式，只要能对应上mask_decoder接口要求的输入格式就行</span></span><br><span class="line">npz_tr_path = <span class="string">&#x27;xx&#x27;</span></span><br><span class="line"><span class="comment"># 选择SAM模型的基础预训练权重</span></span><br><span class="line">model_type = <span class="string">&#x27;vit_b&#x27;</span></span><br><span class="line"><span class="comment"># SAM预训练权重存放地址</span></span><br><span class="line">checkpoint = <span class="string">&#x27;xx/sam_vit_b_01ec64.pth&#x27;</span></span><br><span class="line">num_epochs = <span class="number">800</span></span><br><span class="line"><span class="comment"># 训练好的模型的名字</span></span><br><span class="line">latest_model_name = <span class="string">&quot;xx &quot;</span> + <span class="string">&quot;.pth&quot;</span></span><br><span class="line">best_model_name = <span class="string">&quot;xx&quot;</span> + <span class="string">&quot;.pth&quot;</span></span><br><span class="line"><span class="comment"># 这必须得gpu才能跑起来，指定第几块卡</span></span><br><span class="line">device = <span class="string">&#x27;cuda:0&#x27;</span></span><br><span class="line"><span class="comment"># 训练好的模型保存路径</span></span><br><span class="line">model_save_path = <span class="string">&#x27;xx&#x27;</span></span><br><span class="line"><span class="comment"># 确定保存模型的路径存在</span></span><br><span class="line">os.makedirs(model_save_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 根据上面选定的模型注册预训练模型</span></span><br><span class="line">sam_model = sam_model_registry[model_type](checkpoint=checkpoint).to(device)</span><br><span class="line"><span class="comment"># 开始训练模式</span></span><br><span class="line">sam_model.train()</span><br><span class="line">sam_model.preprocess()</span><br><span class="line"><span class="comment"># 定义优化器和损失函数  用的monai的 用别的也行</span></span><br><span class="line"><span class="comment"># 优化器和损失函数根据自己的任务选择,或者看看别人都选的啥</span></span><br><span class="line">optimizer = torch.optim.Adam(sam_model.mask_decoder.parameters(), lr=<span class="number">1e-5</span>, weight_decay=<span class="number">0</span>)</span><br><span class="line">seg_loss_dice = monai.losses.DiceCELoss(sigmoid=<span class="literal">True</span>, squared_pred=<span class="literal">True</span>, reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"></span><br><span class="line">losses = []</span><br><span class="line">best_loss = <span class="number">1e10</span></span><br><span class="line"><span class="comment"># 解压预处理好的私有数据集</span></span><br><span class="line"><span class="comment"># 肯定有人问这个npz怎么来的,别急,假装你已经有了</span></span><br><span class="line">train_dataset = NpzDataset(npz_tr_path)</span><br><span class="line"><span class="comment"># dataset只是一个数据集,包含你的所有的数据,你肯定不是一股脑放进去</span></span><br><span class="line"><span class="comment"># dataloader配置了从dataset中取数据并放入模型中的方式,比如我这个一次取96个,根据你的数据量选择,小一点的8 大一点的48</span></span><br><span class="line">train_dataloader = DataLoader(train_dataset, batch_size=<span class="number">96</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 开始经典训练流程</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    epoch_loss = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 这你肯定会问为什么能取到image_embedding, gt2D, boxes,points, points_labels的值，因为预处理数据的时候放进去的呀，别急，都说了，假装这个数据你已经处理好了。</span></span><br><span class="line">    <span class="keyword">for</span> step, (image_embedding, gt2D, boxes, points, points_labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(tqdm(train_dataloader)):</span><br><span class="line">        <span class="comment"># 冻结提示编码层</span></span><br><span class="line">        <span class="comment"># 为什么没冻结图像编码层，因为预处理数据的时候已经将图像的编码embedding（这个就是sam图像编码器编码得到的），GT，图像名称作为图像信息存在了npz</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            box_np = boxes.numpy()</span><br><span class="line">            <span class="comment"># 这个是sam编码器要求的，他要求提示要经过ResizeLongestSide转换。</span></span><br><span class="line">            <span class="comment"># 因为送进来的图像若经过缩放就得要求对应提示缩放。sam提供了ResizeLongestSide类来统一解决这个问题（贴心！）</span></span><br><span class="line">            <span class="comment"># 转换出来的效果基本上就是原始坐标随着你图像的长宽而缩放</span></span><br><span class="line">            sam_trans = ResizeLongestSide(sam_model.image_encoder.img_size)</span><br><span class="line">            <span class="comment"># 放缩框的点坐标适应图像的大小</span></span><br><span class="line">            box = sam_trans.apply_boxes(box_np, (gt2D.shape[-<span class="number">2</span>], gt2D.shape[-<span class="number">1</span>]))</span><br><span class="line">            <span class="comment"># 转tensor</span></span><br><span class="line">            box_torch = torch.as_tensor(box, dtype=torch.<span class="built_in">float</span>, device=device)</span><br><span class="line">            <span class="comment"># 根据点和点的label组装起来装到pt里</span></span><br><span class="line">  coords_torch = torch.as_tensor(points, dtype=torch.<span class="built_in">float</span>, device=device)</span><br><span class="line">            labels_torch = torch.as_tensor(points_labels, dtype=torch.<span class="built_in">int</span>, device=device)</span><br><span class="line">            <span class="comment"># coords_torch, labels_torch = coords_torch[None, :, :], labels_torch[None, :]</span></span><br><span class="line">            pt = (coords_torch, labels_torch)</span><br><span class="line">            <span class="comment"># 第一个关键点</span></span><br><span class="line">            <span class="comment"># 如果是点提示就将点传入，框就将框传入，点框结合就一块传进去</span></span><br><span class="line">            sparse_embeddings, dense_embeddings = sam_model.prompt_encoder(</span><br><span class="line">                points=pt,</span><br><span class="line">                boxes=box_torch,</span><br><span class="line">                masks=<span class="literal">None</span>,</span><br><span class="line">            )</span><br><span class="line">        <span class="comment"># 出循环，解冻掩码解码层.仿照就ok 没变动的</span></span><br><span class="line">        <span class="comment"># 这一步其实就是将一系列信息组合给decoder进行解码.image_embedding是图像编码器编码得到的,get_dense_pe这个是图像位置信息,好像是我忘了,</span></span><br><span class="line">        <span class="comment"># sparse_embeddings提示的稀疏编码,dense_embeddings好像是带位置信息的稠密编码(这要是有问题我之后更正)</span></span><br><span class="line">        mask_predictions, _ = sam_model.mask_decoder(</span><br><span class="line">            image_embeddings=image_embedding.to(device),</span><br><span class="line">            image_pe=sam_model.prompt_encoder.get_dense_pe(),</span><br><span class="line">            sparse_prompt_embeddings=sparse_embeddings,</span><br><span class="line">            dense_prompt_embeddings=dense_embeddings,</span><br><span class="line">            multimask_output=<span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 计算损失,梯度归零,损失反向传播,优化</span></span><br><span class="line">        loss_dice = seg_loss_dice(mask_predictions, gt2D.to(device))</span><br><span class="line">        loss = loss_dice</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        epoch_loss += loss.item()</span><br><span class="line"></span><br><span class="line">    epoch_loss /= step</span><br><span class="line">    losses.append(epoch_loss)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;num_epochs:<span class="subst">&#123;num_epochs&#125;</span>,EPOCH: <span class="subst">&#123;epoch&#125;</span>, Loss: <span class="subst">&#123;epoch_loss&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 保存模型</span></span><br><span class="line">    torch.save(sam_model.state_dict(), join(model_save_path, latest_model_name))</span><br><span class="line">    <span class="comment"># save the best model</span></span><br><span class="line">    <span class="keyword">if</span> epoch_loss &lt; best_loss:</span><br><span class="line">        best_loss = epoch_loss</span><br><span class="line">        torch.save(sam_model.state_dict(), join(model_save_path, best_model_name))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="准备数据集">准备数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">join = os.path.join</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> transform, io</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> segment_anything <span class="keyword">import</span> sam_model_registry</span><br><span class="line"><span class="keyword">from</span> segment_anything.utils.transforms <span class="keyword">import</span> ResizeLongestSide</span><br><span class="line"></span><br><span class="line"><span class="comment"># GT存放路径，到文件夹</span></span><br><span class="line">gt_path = <span class="string">&quot;./&quot;</span></span><br><span class="line"><span class="comment"># 组装好npz的保存路径</span></span><br><span class="line">save_path = <span class="string">&quot;./&quot;</span></span><br><span class="line"><span class="comment"># 获取所有GT图像名称</span></span><br><span class="line">names = <span class="built_in">sorted</span>(os.listdir(gt_path))</span><br><span class="line">os.makedirs(save_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line">model_type = <span class="string">&#x27;vit_b&#x27;</span></span><br><span class="line">checkpoint = <span class="string">&#x27;xx/sam_vit_b_01ec64.pth&#x27;</span></span><br><span class="line">device = <span class="string">&#x27;cuda:0&#x27;</span></span><br><span class="line">sam_model = sam_model_registry[model_type](checkpoint=checkpoint).to(device)</span><br><span class="line">imgs = []</span><br><span class="line">gts = []</span><br><span class="line">img_embeddings = []</span><br><span class="line"><span class="comment"># image路径 到最后一层文件夹</span></span><br><span class="line">img_path=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> gt_name <span class="keyword">in</span> tqdm(names):</span><br><span class="line">    <span class="comment"># 如果你是jpg改一下后缀</span></span><br><span class="line">    image_name = gt_name.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>] + <span class="string">&quot;.png&quot;</span></span><br><span class="line">    <span class="comment"># 读取GT</span></span><br><span class="line">    gt_data = io.imread(join(gt_path, gt_name))</span><br><span class="line">    <span class="comment"># GT必须是2D，如果是3D就取前两通道</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(gt_data.shape) == <span class="number">3</span>:</span><br><span class="line">        gt_data = gt_data[:, :, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(gt_data.shape) == <span class="number">2</span>, <span class="string">&#x27;GT must be 2D&#x27;</span></span><br><span class="line">    <span class="comment"># 尺寸转256数值转255</span></span><br><span class="line">    gt_data = transform.resize(gt_data == <span class="number">255</span>, (<span class="number">256</span>, <span class="number">256</span>), order=<span class="number">0</span>,</span><br><span class="line">                               preserve_range=<span class="literal">True</span>, mode=<span class="string">&#x27;constant&#x27;</span>)</span><br><span class="line">    gt_data = np.uint8(gt_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 排除GT特别小的情况，这条可以不加</span></span><br><span class="line">    <span class="keyword">if</span> np.<span class="built_in">sum</span>(gt_data) &gt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">assert</span> np.<span class="built_in">max</span>(gt_data) == <span class="number">1</span> <span class="keyword">and</span> np.unique(gt_data).shape[<span class="number">0</span>] == <span class="number">2</span>, <span class="string">&#x27;GT must be 2D&#x27;</span></span><br><span class="line">        image_data = io.imread(join(img_path, image_name))</span><br><span class="line">        <span class="comment"># 计算最大值最小值</span></span><br><span class="line">        lower_bound, upper_bound = np.percentile(image_data, <span class="number">0.5</span>), np.percentile(image_data, <span class="number">99.5</span>)</span><br><span class="line">        <span class="comment"># 排除特别特殊的像素</span></span><br><span class="line">        image_data_pre = np.clip(image_data, lower_bound, upper_bound)</span><br><span class="line">        <span class="comment"># 归一化</span></span><br><span class="line">        image_data_pre = (image_data_pre - np.<span class="built_in">min</span>(image_data_pre)) / (</span><br><span class="line">                np.<span class="built_in">max</span>(image_data_pre) - np.<span class="built_in">min</span>(image_data_pre)) * <span class="number">255.0</span></span><br><span class="line">        image_data_pre[image_data == <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 归一化</span></span><br><span class="line">        image_data_pre = transform.resize(image_data_pre, (<span class="number">256</span>, <span class="number">256</span>), order=<span class="number">3</span>,</span><br><span class="line">                                          preserve_range=<span class="literal">True</span>, mode=<span class="string">&#x27;constant&#x27;</span>, anti_aliasing=<span class="literal">True</span>)</span><br><span class="line">        image_data_pre = np.uint8(image_data_pre)</span><br><span class="line"></span><br><span class="line">        imgs.append(image_data_pre)</span><br><span class="line">        gts.append(gt_data)</span><br><span class="line">        <span class="comment"># SAM提供的resize到1024</span></span><br><span class="line">        sam_transform = ResizeLongestSide(sam_model.image_encoder.img_size)</span><br><span class="line">        resize_img = sam_transform.apply_image(image_data_pre)</span><br><span class="line">        <span class="comment"># resize_img是通道在后,sam要求通道在前，transposehi是对resize_img数组进行维度重排（dimension reordering）的操作，变成CHW</span></span><br><span class="line">        resize_img_tensor = torch.as_tensor(resize_img.transpose(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)).to(device)</span><br><span class="line">        <span class="comment"># 增加一个channel假装当作有一个batchsize输入到sam_model.image_encoder</span></span><br><span class="line">        input_image = sam_model.preprocess(resize_img_tensor[<span class="literal">None</span>, :, :, :])  <span class="comment"># (1, 3, 1024, 1024)</span></span><br><span class="line">        <span class="comment"># 提前计算图像embedding</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            embedding = sam_model.image_encoder(input_image)</span><br><span class="line">            img_embeddings.append(embedding.cpu().numpy()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面数据已经处理好并存在数组了，需要数据字典存在npz中</span></span><br><span class="line"><span class="comment"># 沿着纵轴堆砌，每一个都是(256, 256, 3),堆起来是(n, 256, 256, 3)</span></span><br><span class="line">imgs = np.stack(imgs, axis=<span class="number">0</span>)  <span class="comment"># (n, 256, 256, 3)</span></span><br><span class="line">gts = np.stack(gts, axis=<span class="number">0</span>)  <span class="comment"># (n, 256, 256)</span></span><br><span class="line">img_embeddings = np.stack(img_embeddings, axis=<span class="number">0</span>)  <span class="comment"># (n, 1, 256, 64, 64)</span></span><br><span class="line"><span class="comment"># np的保存npz操作</span></span><br><span class="line">np.savez_compressed(join(save_path, <span class="string">&#x27;.npz&#x27;</span>), imgs=imgs, gts=gts, img_embeddings=img_embeddings)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">join = os.path.join</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">import</span> monai</span><br><span class="line"><span class="keyword">from</span> segment_anything <span class="keyword">import</span> sam_model_registry</span><br><span class="line"><span class="keyword">from</span> segment_anything.utils.transforms <span class="keyword">import</span> ResizeLongestSide</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">torch.manual_seed(<span class="number">2023</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造自己的Dataset继承Dataset类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyselfDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data_root</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;into init&quot;</span>)</span><br><span class="line">        self.data_root = data_root</span><br><span class="line">        <span class="comment"># 访问npz文件</span></span><br><span class="line">        self.npz_files = <span class="built_in">sorted</span>(os.listdir(self.data_root))</span><br><span class="line">        <span class="comment"># 去除npz里的数据</span></span><br><span class="line">        self.npz_data = [np.load(join(data_root, f)) <span class="keyword">for</span> f <span class="keyword">in</span> self.npz_files]</span><br><span class="line">        <span class="comment"># 将取出来的数据放在变量保存</span></span><br><span class="line">        self.ori_gts = np.vstack([d[<span class="string">&#x27;gts&#x27;</span>] <span class="keyword">for</span> d <span class="keyword">in</span> self.npz_data])</span><br><span class="line">        self.img_embeddings = np.vstack([d[<span class="string">&#x27;img_embeddings&#x27;</span>] <span class="keyword">for</span> d <span class="keyword">in</span> self.npz_data])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.ori_gts.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        img_embed = self.img_embeddings[index]</span><br><span class="line">        gt2D = self.ori_gts[index]</span><br><span class="line">        <span class="comment"># 获取非零点坐标</span></span><br><span class="line">        y_indices, x_indices = np.where(gt2D &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 获取GT坐标框</span></span><br><span class="line">        x_min, x_max = np.<span class="built_in">min</span>(x_indices), np.<span class="built_in">max</span>(x_indices)</span><br><span class="line">        y_min, y_max = np.<span class="built_in">min</span>(y_indices), np.<span class="built_in">max</span>(y_indices)</span><br><span class="line">        <span class="comment"># 在GT框加扰动</span></span><br><span class="line">        H, W = gt2D.shape</span><br><span class="line">        x_min = <span class="built_in">max</span>(<span class="number">0</span>, x_min - np.random.randint(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">        x_max = <span class="built_in">min</span>(W, x_max + np.random.randint(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">        y_min = <span class="built_in">max</span>(<span class="number">0</span>, y_min - np.random.randint(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">        y_max = <span class="built_in">min</span>(H, y_max + np.random.randint(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">        bboxes = np.array([x_min, y_min, x_max, y_max])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在GT在5像素以内的地方随机选择两个背景点</span></span><br><span class="line">        y_zero, x_zero = np.where(gt2D == <span class="number">0</span>)</span><br><span class="line">        y_zero = np.unique(y_zero)</span><br><span class="line">        x_zero = np.unique(x_zero)</span><br><span class="line">        y_list = y_zero[(y_min - <span class="number">5</span> &lt; y_zero) &amp; (y_zero &lt; y_max + <span class="number">5</span>)]</span><br><span class="line">        x_list = x_zero[(x_min - <span class="number">5</span> &lt; x_zero) &amp; (x_zero &lt; x_max + <span class="number">5</span>)]</span><br><span class="line">        y1, y2 = random.choices(y_list, k=<span class="number">2</span>)</span><br><span class="line">        x1, x2 = random.choices(x_list, k=<span class="number">2</span>)</span><br><span class="line">        background_index1 = [x1, y1]</span><br><span class="line">        background_index2 = [x2, y2]</span><br><span class="line">        <span class="comment"># 在GT内随机选择前景点</span></span><br><span class="line">        foreground_index1, foreground_index2, foreground_index3 = random.choices(</span><br><span class="line">            np.argwhere(gt2D == <span class="number">1</span>), k=<span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 将所有选择好的点添加到list，如果是单点，不需要直接返回点的index就好。</span></span><br><span class="line">        pt_list_s = []</span><br><span class="line">        pt_list_s.append(background_index1)</span><br><span class="line">        pt_list_s.append(background_index2)</span><br><span class="line">        pt_list_s.append(foreground_index1)</span><br><span class="line">        pt_list_s.append(foreground_index2)</span><br><span class="line">        pt_list_s.append(foreground_index3)</span><br><span class="line">        points = pt_list_s</span><br><span class="line">        <span class="comment"># 0是背景1是前景</span></span><br><span class="line">        points_labels = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> torch.tensor(img_embed).<span class="built_in">float</span>(), torch.tensor(gt2D[<span class="literal">None</span>, :, :]).long(), torch.tensor(</span><br><span class="line">            bboxes).<span class="built_in">float</span>(), torch.tensor(points).<span class="built_in">float</span>(), torch.tensor(points_labels).<span class="built_in">float</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/">深度学习论文</category>
      
      
      
      <comments>http://example.com/2024/05/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/SAM/%E5%BE%AE%E8%B0%83%E6%B5%81%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉树展开为链表</title>
      <link>http://example.com/2024/05/27/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</link>
      <guid>http://example.com/2024/05/27/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Mon, 27 May 2024 09:11:14 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;给你二叉树的根结点 &lt;code&gt;root&lt;/code&gt; ，请你将它展开为一个单链表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;展开后的单链表应该同样使用 &lt;code&gt;TreeNode&lt;/code&gt; ，其中
&lt;code&gt;right&lt;/code&gt; 子指针指向链表中下一个结点，而左子指针</description>
        
      
      
      
      <content:encoded><![CDATA[<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中<code>right</code> 子指针指向链表中下一个结点，而左子指针始终为<code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin"><strong>先序遍历</strong></a>顺序相同。</li></ul><p>类莫里斯方法，旋转子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">//左子树为 null，直接考虑下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找左子树最右边的节点</span></span><br><span class="line">            TreeNode pre = root.left;</span><br><span class="line">            <span class="keyword">while</span> (pre.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre = pre.right;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">            pre.right = root.right;</span><br><span class="line">            <span class="comment">// 将左子树插入到右子树的地方</span></span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 考虑下一个节点</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode pre = root.left;</span><br><span class="line">            <span class="keyword">while</span>(pre.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre = pre.right;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.right = root.right;</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变形的后序遍历进行递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        flatten(root.right);</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        root.right = pre;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        pre = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常的后序遍历是左→右→打印</p><p>这里变形后是右→左→变换</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/hot-%E4%BA%8C%E5%8F%89%E6%A0%91/">hot/二叉树</category>
      
      
      
      <comments>http://example.com/2024/05/27/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉树的右视图</title>
      <link>http://example.com/2024/05/23/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</link>
      <guid>http://example.com/2024/05/23/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</guid>
      <pubDate>Thu, 23 May 2024 08:49:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;给定一个二叉树的 &lt;strong&gt;根节点&lt;/strong&gt;
&lt;code&gt;root&lt;/code&gt;，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;
&lt;p&gt;我的思路：bfs层序遍历，返回每一层最右侧的值就行。&lt;/p&gt;
&lt;figure cl</description>
        
      
      
      
      <content:encoded><![CDATA[<p>给定一个二叉树的 <strong>根节点</strong><code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>我的思路：bfs层序遍历，返回每一层最右侧的值就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">                <span class="keyword">if</span>(size == <span class="number">1</span>) res.add(node.val);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dfs">dfs</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max_depth = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; depthStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        depthStack.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodeStack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeStack.pop();</span><br><span class="line">            <span class="keyword">int</span> depth = depthStack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 维护二叉树的最大深度</span></span><br><span class="line">                max_depth = Math.max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果不存在对应深度的节点我们才插入</span></span><br><span class="line">                <span class="keyword">if</span> (!rightmostValueAtDepth.containsKey(depth)) &#123;</span><br><span class="line">                    rightmostValueAtDepth.put(depth, node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nodeStack.push(node.left);</span><br><span class="line">                nodeStack.push(node.right);</span><br><span class="line">                depthStack.push(depth + <span class="number">1</span>);</span><br><span class="line">                depthStack.push(depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; rightView = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> depth = <span class="number">0</span>; depth &lt;= max_depth; depth++) &#123;</span><br><span class="line">            rightView.add(rightmostValueAtDepth.get(depth));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归">递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth, List&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth == ans.size()) &#123; <span class="comment">// 这个深度首次遇到</span></span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right, depth + <span class="number">1</span>, ans); <span class="comment">// 先递归右子树，保证首次遇到的一定是最右边的节点</span></span><br><span class="line">        dfs(root.left, depth + <span class="number">1</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans.size() &lt;= depth) </span><br><span class="line">            ans.add(node.val);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            ans.set(depth, node.val);</span><br><span class="line">        dfs(node.left, depth + <span class="number">1</span>);</span><br><span class="line">        dfs(node.right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/hot-%E4%BA%8C%E5%8F%89%E6%A0%91/">hot/二叉树</category>
      
      
      
      <comments>http://example.com/2024/05/23/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉搜索树中第K小的元素</title>
      <link>http://example.com/2024/05/20/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <guid>http://example.com/2024/05/20/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <pubDate>Mon, 20 May 2024 08:27:24 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;给定一个二叉搜索树的根节点 &lt;code&gt;root&lt;/code&gt; ，和一个整数
&lt;code&gt;k&lt;/code&gt; ，请你设计一个算法查找其中第 &lt;code&gt;k&lt;/code&gt;
个最小元素（从 1 开始计数）。&lt;/p&gt;
&lt;p&gt;递归中序遍历：&lt;/p&gt;
&lt;figure class</description>
        
      
      
      
      <content:encoded><![CDATA[<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数<code>k</code> ，请你设计一个算法查找其中第 <code>k</code>个最小元素（从 1 开始计数）。</p><p>递归中序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; a = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inorder(root, a);</span><br><span class="line">        <span class="keyword">return</span> a.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">        inorder(root.left, a);</span><br><span class="line">        a.add(root.val);</span><br><span class="line">        inorder(root.right, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用栈迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line"><span class="keyword">while</span>((stack.size()&gt;<span class="number">0</span> || root!=<span class="keyword">null</span>) &amp;&amp; k!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//不断往左子树方向走，每走一次就将当前节点保存到栈中</span></span><br><span class="line"><span class="comment">//这是模拟递归的调用</span></span><br><span class="line"><span class="keyword">if</span>(root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">stack.add(root);</span><br><span class="line">root = root.left;</span><br><span class="line"><span class="comment">//当前节点为空，说明左边走到头了，从栈中弹出节点并保存</span></span><br><span class="line"><span class="comment">//然后转向右边节点，继续上面整个过程</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">TreeNode tmp = stack.pop();</span><br><span class="line">res.add(tmp.val);</span><br><span class="line">root = tmp.right;</span><br><span class="line">                k--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.get(res.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左神套路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftNodes = countNodes(root.left);</span><br><span class="line">        <span class="keyword">if</span>(leftNodes &lt; k - <span class="number">1</span>)&#123;  <span class="comment">//答案存在右子树中</span></span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.right,k - leftNodes - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftNodes == k - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.left,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左神递归套路分析左右子树返回信息只需要节点数，因此无需额外定义数据结构</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">       <span class="comment">//base case返回0</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//递归处理左右子树并接收返回值</span></span><br><span class="line">        <span class="keyword">int</span> leftNodes = countNodes(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightNodes = countNodes(root.right);</span><br><span class="line">       <span class="comment">//判断分析本层递归返回值的具体值</span></span><br><span class="line">        <span class="keyword">return</span> leftNodes + rightNodes + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二叉搜索树，第k个，那常规做法就是就是中序遍历第k个</span></span><br><span class="line">        dfs(root,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        dfs(root.left,k);</span><br><span class="line">        <span class="keyword">if</span>(now==k)&#123;</span><br><span class="line">            res=root.val;</span><br><span class="line">            now++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        now++;</span><br><span class="line">        dfs(root.right,k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈迭代的另一种写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            --k;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/hot-%E4%BA%8C%E5%8F%89%E6%A0%91/">hot/二叉树</category>
      
      
      
      <comments>http://example.com/2024/05/20/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>验证二叉搜索树</title>
      <link>http://example.com/2024/05/17/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <guid>http://example.com/2024/05/17/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <pubDate>Fri, 17 May 2024 08:32:42 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;给你一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt;
，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有效&lt;/strong&gt; 二叉搜索树定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;节点的左&lt;/p&gt;
&lt;p&gt;子树&lt;/p&gt;
&lt;p&gt;只包含&lt;/p</description>
        
      
      
      
      <content:encoded><![CDATA[<p>给你一个二叉树的根节点 <code>root</code>，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li><p>节点的左</p><p>子树</p><p>只包含</p><p>小于</p><p>当前节点的数。</p></li><li><p>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</p></li><li><p>所有左子树和右子树自身必须也是二叉搜索树。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">long</span> lower, <span class="keyword">long</span> upper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= lower || root.val &gt;= upper) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root.left, lower, root.val) &amp;&amp; helper(root.right, root.val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = inorderTraversal(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i) &gt;= list.get(i+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; a = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inorder(root, a);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">        inorder(root.left, a);</span><br><span class="line">        a.add(root.val);</span><br><span class="line">        inorder(root.right, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">double</span> inorder = -Double.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">              <span class="comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (root.val &lt;= inorder) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root.val;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/hot-%E4%BA%8C%E5%8F%89%E6%A0%91/">hot/二叉树</category>
      
      
      
      <comments>http://example.com/2024/05/17/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>将有序数组转换为二叉搜索树</title>
      <link>http://example.com/2024/05/16/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <guid>http://example.com/2024/05/16/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <pubDate>Thu, 16 May 2024 08:37:50 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，其中元素已经按
&lt;strong&gt;升序&lt;/strong&gt; 排列，请你将其转换为一棵平衡二叉搜索树。&lt;/p&gt;
&lt;p&gt;平衡二叉树（balanced binary
tree）中任意节点的左子树和右子树的高度之差的绝对值不</description>
        
      
      
      
      <content:encoded><![CDATA[<p>给你一个整数数组 <code>nums</code> ，其中元素已经按<strong>升序</strong> 排列，请你将其转换为一棵平衡二叉搜索树。</p><p>平衡二叉树（balanced binarytree）中任意节点的左子树和右子树的高度之差的绝对值不超过 1 。</p><p>二叉搜索树（binary search tree）满足以下条件。</p><ol type="1"><li>对于根节点，左子树中所有节点的值 &lt; 根节点的值 &lt;右子树中所有节点的值。</li><li>任意节点的左、右子树也是二叉搜索树，即同样满足条件 <code>1.</code>。</li></ol><p>AVL和红黑树都是二叉平衡搜索树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l&gt;r ? <span class="keyword">null</span> : <span class="keyword">new</span> TreeNode(nums[(l+r)/<span class="number">2</span>], build(nums,l,(l+r)/<span class="number">2</span>-<span class="number">1</span>), build(nums,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择中间左边的作为根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = helper(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右边的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总是选择中间位置右边的数字作为根节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = helper(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任意中间位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择任意一个中间位置数字作为根节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right + rand.nextInt(<span class="number">2</span>)) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = helper(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/hot-%E4%BA%8C%E5%8F%89%E6%A0%91/">hot/二叉树</category>
      
      
      
      <comments>http://example.com/2024/05/16/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉树的层序遍历</title>
      <link>http://example.com/2024/05/15/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <guid>http://example.com/2024/05/15/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <pubDate>Wed, 15 May 2024 06:01:58 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;使用栈或队列&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>使用栈或队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化队列和列表</span></span><br><span class="line">Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">q.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用队列进行层序遍历</span></span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            List&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode cu = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(cu != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    l.add(cu.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cu.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(cu.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cu.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(cu.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//列表非空加入</span></span><br><span class="line">            <span class="keyword">if</span>(l.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(l);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; rst = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        doLevelOrder(rst, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLevelOrder</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rst, TreeNode node, Integer deep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deep++;</span><br><span class="line">        <span class="keyword">if</span> (rst.size() &lt; deep) &#123; <span class="comment">// 为了防止出现空数组</span></span><br><span class="line">            ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            rst.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rst.get(deep - <span class="number">1</span>).add(node.val);            </span><br><span class="line">        </span><br><span class="line">        doLevelOrder(rst, node.left, deep);</span><br><span class="line">        doLevelOrder(rst, node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/hot-%E4%BA%8C%E5%8F%89%E6%A0%91/">hot/二叉树</category>
      
      
      
      <comments>http://example.com/2024/05/15/%E5%8A%9B%E6%89%A3/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>http://example.com/2024/05/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/swintrans/</link>
      <guid>http://example.com/2024/05/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/swintrans/</guid>
      <pubDate>Tue, 14 May 2024 12:14:15 GMT</pubDate>
      
        
        
      <description>&lt;hr&gt;
&lt;hr&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b</description>
        
      
      
      
      <content:encoded><![CDATA[<hr><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowAttention</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">r&quot;&quot;&quot; Window based multi-head self attention (W-MSA) module with relative position bias.</span></span><br><span class="line"><span class="string">    It supports both of shifted and non-shifted window.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dim (int): Number of input channels.</span></span><br><span class="line"><span class="string">        window_size (tuple[int]): The height and width of the window.</span></span><br><span class="line"><span class="string">        num_heads (int): Number of attention heads.</span></span><br><span class="line"><span class="string">        qkv_bias (bool, optional):  If True, add a learnable bias to query, key, value. Default: True</span></span><br><span class="line"><span class="string">        qk_scale (float | None, optional): Override default qk scale of head_dim ** -0.5 if set</span></span><br><span class="line"><span class="string">        attn_drop (float, optional): Dropout ratio of attention weight. Default: 0.0</span></span><br><span class="line"><span class="string">        proj_drop (float, optional): Dropout ratio of output. Default: 0.0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dim, window_size, num_heads, qkv_bias=<span class="literal">True</span>, qk_scale=<span class="literal">None</span>, attn_drop=<span class="number">0.</span>, proj_drop=<span class="number">0.</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.window_size = window_size  <span class="comment"># Wh, Ww</span></span><br><span class="line">        self.num_heads = num_heads <span class="comment"># nH</span></span><br><span class="line">        head_dim = dim // num_heads <span class="comment"># 每个注意力头对应的通道数</span></span><br><span class="line">        self.scale = qk_scale <span class="keyword">or</span> head_dim ** -<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># define a parameter table of relative position bias</span></span><br><span class="line">        self.relative_position_bias_table = nn.Parameter(</span><br><span class="line">            torch.zeros((<span class="number">2</span> * window_size[<span class="number">0</span>] - <span class="number">1</span>) * (<span class="number">2</span> * window_size[<span class="number">1</span>] - <span class="number">1</span>), num_heads))  <span class="comment"># 设置一个形状为（2*(Wh-1) * 2*(Ww-1), nH）的可学习变量，用于后续的位置编码</span></span><br><span class="line"></span><br><span class="line">        self.qkv = nn.Linear(dim, dim * <span class="number">3</span>, bias=qkv_bias)</span><br><span class="line">        self.attn_drop = nn.Dropout(attn_drop)</span><br><span class="line">        self.proj = nn.Linear(dim, dim)</span><br><span class="line">        self.proj_drop = nn.Dropout(proj_drop)</span><br><span class="line"></span><br><span class="line">        trunc_normal_(self.relative_position_bias_table, std=<span class="number">.02</span>)</span><br><span class="line">        self.softmax = nn.Softmax(dim=-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 相关位置编码...</span></span><br></pre></td></tr></table></figure><h3 id="相对位置编码的构建过程">相对位置编码的构建过程</h3><p>构建窗口window</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window_size = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">coords_h = torch.arange(window_size[<span class="number">0</span>])</span><br><span class="line">coords_w = torch.arange(window_size[<span class="number">1</span>])</span><br><span class="line">coords = torch.meshgrid([coords_h, coords_w]) <span class="comment"># -&gt; 2*(wh, ww)</span></span><br><span class="line"><span class="built_in">print</span>(coords)</span><br><span class="line"><span class="comment">#(tensor([[0, 0],</span></span><br><span class="line"><span class="comment">#        [1, 1]]), </span></span><br><span class="line"><span class="comment">#tensor([[0, 1],</span></span><br><span class="line"><span class="comment">#       [0, 1]]))</span></span><br></pre></td></tr></table></figure><p>展开</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">coords = torch.stack(coords)  <span class="comment"># 2, Wh, Ww</span></span><br><span class="line">coords_flatten = torch.flatten(coords, <span class="number">1</span>)  <span class="comment"># 2, Wh*Ww</span></span><br><span class="line"><span class="built_in">print</span>(coords_flatten)</span><br><span class="line"><span class="comment">#tensor([[0, 0, 1, 1],</span></span><br><span class="line"><span class="comment">#        [0, 1, 0, 1]])</span></span><br></pre></td></tr></table></figure><p>进行转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">relative_coords_first = coords_flatten[:, :, <span class="literal">None</span>]  <span class="comment"># 2, wh*ww, 1</span></span><br><span class="line">relative_coords_second = coords_flatten[:, <span class="literal">None</span>, :] <span class="comment"># 2, 1, wh*ww</span></span><br><span class="line"><span class="built_in">print</span>(relative_coords_first,relative_coords_second)</span><br><span class="line"><span class="comment">#tensor([[[0],</span></span><br><span class="line">         [<span class="number">0</span>],</span><br><span class="line">         [<span class="number">1</span>],</span><br><span class="line">         [<span class="number">1</span>]],</span><br><span class="line"></span><br><span class="line">        [[<span class="number">0</span>],</span><br><span class="line">         [<span class="number">1</span>],</span><br><span class="line">         [<span class="number">0</span>],</span><br><span class="line">         [<span class="number">1</span>]]]) </span><br><span class="line"><span class="comment">#tensor([[[0, 0, 1, 1]],[[0, 1, 0, 1]]])</span></span><br></pre></td></tr></table></figure><p><img src="https://datawhalechina.github.io/thorough-pytorch/_images/relative_pos_code.png" style="zoom: 67%;"></p><p>进行相对位置编码计算，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">relative_coords_first = coords_flatten[:, :, <span class="literal">None</span>]  <span class="comment"># 2, wh*ww, 1</span></span><br><span class="line">relative_coords_second = coords_flatten[:, <span class="literal">None</span>, :] <span class="comment"># 2, 1, wh*ww</span></span><br><span class="line">relative_coords = relative_coords_first - relative_coords_second <span class="comment"># 最终得到 2, wh*ww, wh*ww 形状的张量</span></span><br></pre></td></tr></table></figure><p>因为采取的是相减，所以得到的索引是从负数开始的，<strong>我们加上偏移量，让其从0 开始</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">relative_coords = relative_coords.permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>).contiguous() <span class="comment"># Wh*Ww, Wh*Ww, 2</span></span><br><span class="line">relative_coords[:, :, <span class="number">0</span>] += self.window_size[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">relative_coords[:, :, <span class="number">1</span>] += self.window_size[<span class="number">1</span>] - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>后续我们需要将其展开成一维偏移量。而对于(1，2）和（2，1）这两个坐标。在二维上是不同的，<strong>但是通过将 x,y坐标相加转换为一维偏移的时候，他的偏移量是相等的</strong>。</p><p><img src="https://datawhalechina.github.io/thorough-pytorch/_images/bias0.png" style="zoom: 50%;"></p><p>所以最后我们对其中做了个乘法操作，以进行区分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relative_coords[:, :, <span class="number">0</span>] *= <span class="number">2</span> * self.window_size[<span class="number">1</span>] - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后再最后一维上进行求和，展开成一个一维坐标，并注册为一个不参与网络学习的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">relative_position_index = relative_coords.<span class="built_in">sum</span>(-<span class="number">1</span>)  <span class="comment"># Wh*Ww, Wh*Ww</span></span><br><span class="line">self.register_buffer(<span class="string">&quot;relative_position_index&quot;</span>, relative_position_index)</span><br></pre></td></tr></table></figure><p>之前计算的是相对位置索引，并不是相对位置偏置参数。真正使用到的可训练参数𝐵^是保存在<code>relative position bias table</code>表里的，这个表的长度是等于<strong>(2M−1) × (2M−1)</strong>(在二维位置坐标中线性变化乘以2M-1导致)的。那么上述公式中的相对位置偏执参数B是根据上面的相对位置索引表根据查<code>relative position bias table</code>表得到的。</p><p>前向传播函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, mask=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        x: input features with shape of (num_windows*B, N, C)</span></span><br><span class="line"><span class="string">        mask: (0/-inf) mask with shape of (num_windows, Wh*Ww, Wh*Ww) or None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    B_, N, C = x.shape</span><br><span class="line">    qkv = self.qkv(x).reshape(B_, N, <span class="number">3</span>, self.num_heads, C // self.num_heads).permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    q, k, v = qkv[<span class="number">0</span>], qkv[<span class="number">1</span>], qkv[<span class="number">2</span>]  <span class="comment"># make torchscript happy (cannot use tensor as tuple)</span></span><br><span class="line"></span><br><span class="line">    q = q * self.scale</span><br><span class="line">    attn = (q @ k.transpose(-<span class="number">2</span>, -<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    relative_position_bias = self.relative_position_bias_table[self.relative_position_index.view(-<span class="number">1</span>)].view(</span><br><span class="line">        self.window_size[<span class="number">0</span>] * self.window_size[<span class="number">1</span>], self.window_size[<span class="number">0</span>] * self.window_size[<span class="number">1</span>], -<span class="number">1</span>)  <span class="comment"># Wh*Ww,Wh*Ww,nH</span></span><br><span class="line">    relative_position_bias = relative_position_bias.permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>).contiguous()  <span class="comment"># nH, Wh*Ww, Wh*Ww</span></span><br><span class="line">    attn = attn + relative_position_bias.unsqueeze(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        nW = mask.shape[<span class="number">0</span>]</span><br><span class="line">        attn = attn.view(B_ // nW, nW, self.num_heads, N, N) + mask.unsqueeze(<span class="number">1</span>).unsqueeze(<span class="number">0</span>)</span><br><span class="line">        attn = attn.view(-<span class="number">1</span>, self.num_heads, N, N)</span><br><span class="line">        attn = self.softmax(attn)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        attn = self.softmax(attn)</span><br><span class="line"></span><br><span class="line">    attn = self.attn_drop(attn)</span><br><span class="line"></span><br><span class="line">    x = (attn @ v).transpose(<span class="number">1</span>, <span class="number">2</span>).reshape(B_, N, C)</span><br><span class="line">    x = self.proj(x)</span><br><span class="line">    x = self.proj_drop(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2024/05/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/swintrans/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
