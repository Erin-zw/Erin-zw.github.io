<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Erin枫</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>来者犹可追</description>
    <pubDate>Fri, 22 Mar 2024 02:07:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>axial attention</title>
      <link>http://example.com/2024/03/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/MedT/axial_attention/</link>
      <guid>http://example.com/2024/03/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/MedT/axial_attention/</guid>
      <pubDate>Fri, 22 Mar 2024 02:05:28 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;axial-attention-in-multidimensional-transformers&quot;&gt;AXIAL
ATTENTION IN MULTIDIMENSIONAL TRANSFORMERS&lt;/h2&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="axial-attention-in-multidimensional-transformers">AXIALATTENTION IN MULTIDIMENSIONAL TRANSFORMERS</h2>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/">深度学习论文</category>
      
      
      
      <comments>http://example.com/2024/03/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/MedT/axial_attention/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MedTrans</title>
      <link>http://example.com/2024/03/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/MedT/MedTrans/</link>
      <guid>http://example.com/2024/03/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/MedT/MedTrans/</guid>
      <pubDate>Thu, 21 Mar 2024 11:28:43 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;medical-transformer-gated-axial-attention-for-medical-image-segmentation&quot;&gt;Medical
Transformer: Gated Axial-Attention for Medical Im</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="medical-transformer-gated-axial-attention-for-medical-image-segmentation">MedicalTransformer: Gated Axial-Attention for Medical Image Segmentation</h2><h3 id="概述">概述</h3><p>​ 卷积结构存在内在的inductivebiases（归纳偏差），缺乏对图像远程依赖关系的理解。同时对于数据集规要求较高。</p><p>​作者提出门控轴向注意力机制，并且提出一种叫做Local-Global（LoGo）的训练策略高效训练模型。在三个数据集上达到了更好的效果相比卷积模型和其他注意力模型。</p><p>​作者认为虽然Deeplab，SETR这些网络提高了表现，但是还未被探索完全，因为编码解码器仍然是以卷积结构作为主要模块。</p><p>​同时trans结构需要大规模数据集，但是对于医学图像难以做到，并且较少的图像会导致训练位置编码变得困难。所以提出门控的注意力控制位置编码进入qkv的信息量。由于是可学习的，所以可以适用于基本上所有规模的数据集。根据数据集大小，这些门会学习是否图片的数量可以学习到正确的位置编码。根据判断学习到的位置编码是否有用，这些门参数会收敛到0或者一个highvalue。</p><p>​提出一种局部全局（LoGo）训练策略，使用浅全局分支和对医学图像的补丁进行操作的深层局部分支。不仅关注整张图片同时还关注局部细节。</p><p><strong>总结：</strong></p><ul><li>提出了一种门控位置敏感的轴向注意机制，即使在较小的数据集上也能很好地工作</li><li>引入LoGo训练方法</li><li>提出Med-Trans</li><li>提高了表现</li></ul><h3 id="实现细节">实现细节</h3><p>模型结构：<img src="/images/深度学习论文/MedT/1.png" style="zoom:67%;"></p><p><strong>轴向注意力：</strong></p><p>将特征图分为两个维度（长宽轴）进行注意力计算。具有更高的计算效率。</p><p>所谓的轴向注意力就是对于位置编码分别对qkv进行学习，然后进行相加。具体看公式：<span class="math display">\[y=\sum softmax(qk+qr_q+kr_k)(v+r_v)\]</span> <strong>门控轴向注意力：</strong></p><p>作者认为，对于小规模数据集的实验（医学图像分割中常见的情况），位置偏差很难学习，因此在编码远程交互时并不总是准确的。在学习的相对位置编码不够准确的情况下，将它们添加到各自的键、查询和值张量中将导致性能下降。因此提出门控轴向注意力，也就是加入了门控制位置信息量的输入。公式：<span class="math display">\[y=\sum softmax(qk+G_qqr_q+G_kkr_k)(G_{v_1}v+G_{v_2}r_v)\]</span> <strong>LoGo训练策略：</strong></p><p>为了提高对图像的整体理解，作者建议在网络中使用两个分支，即作用于图像原始分辨率的全局分支和作用于图像补丁的局部分支。</p><p>全局分支中，减少了门控轴向变压器层的数量，因为观察到所提出的变压器模型的前几个块足以模拟长范围依赖性。在本地分支中，创建16 个大小为 I/4 × I/4 的图像块，其中 I是原始图像的尺寸。在本地分支中，每个补丁通过网络进行前馈，并根据输出特征图的位置对其进行重新采样以获得输出特征图。然后将两个分支的输出特征图相加并通过1 × 1 卷积层以生成输出分割掩模。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/">深度学习论文</category>
      
      
      
      <comments>http://example.com/2024/03/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/MedT/MedTrans/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>异位词</title>
      <link>http://example.com/2024/03/20/%E5%8A%9B%E6%89%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E5%BC%82%E4%BD%8D%E8%AF%8D/</link>
      <guid>http://example.com/2024/03/20/%E5%8A%9B%E6%89%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E5%BC%82%E4%BD%8D%E8%AF%8D/</guid>
      <pubDate>Wed, 20 Mar 2024 03:24:53 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;给定两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt;
中所有 &lt;code&gt;p&lt;/code&gt; 的 &lt;strong&gt;异位词&lt;/strong&gt;
的子串，返回这些子串的起始索引。不考虑答案输出的顺序。&lt;/p&gt;
&lt;p</description>
        
      
      
      
      <content:encoded><![CDATA[<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code>中所有 <code>p</code> 的 <strong>异位词</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong>指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/hot-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">hot/滑动窗口</category>
      
      
      
      <comments>http://example.com/2024/03/20/%E5%8A%9B%E6%89%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E5%BC%82%E4%BD%8D%E8%AF%8D/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>无重复子串</title>
      <link>http://example.com/2024/03/19/%E5%8A%9B%E6%89%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/</link>
      <guid>http://example.com/2024/03/19/%E5%8A%9B%E6%89%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/</guid>
      <pubDate>Tue, 19 Mar 2024 12:37:57 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的
&lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext</description>
        
      
      
      
      <content:encoded><![CDATA[<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的<strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>子串中字符一定是连续的</p><p>思路：</p><p>我们先定义一个窗口，i指向左边界，rk指向右边界，我们先从i=0找到不重复最大子串的右边界rk。我们使用变量记录长度并且把子串内容存入哈希集合中。此时我们将i右移一位，把窗口最左侧内容移初出哈希集合。我们的rk也继续右移找到最大不重复子串，因为rk只会变大。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rk = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> L = s.length();</span><br><span class="line">        Set&lt;Character&gt; occ = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                occ.remove(s.charAt(i-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(rk+<span class="number">1</span>&lt;L&amp;&amp;!occ.contains(s.charAt(rk+<span class="number">1</span>)))&#123;</span><br><span class="line">                occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">                rk++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,rk-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/hot-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">hot/滑动窗口</category>
      
      
      
      <comments>http://example.com/2024/03/19/%E5%8A%9B%E6%89%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>接雨水</title>
      <link>http://example.com/2024/03/19/%E5%8A%9B%E6%89%A3/%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</link>
      <guid>http://example.com/2024/03/19/%E5%8A%9B%E6%89%A3/%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</guid>
      <pubDate>Tue, 19 Mar 2024 12:09:53 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个非负整数表示每个宽度为 &lt;code&gt;1&lt;/code&gt;
的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas</description>
        
      
      
      
      <content:encoded><![CDATA[<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code>的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p><img src="/images/力扣/双指针/1.png" style="zoom:67%;"></p><p><img src="/../../images/力扣/双指针/1.png" alt="1" style="zoom: 33%;"></p><p>每个点都有一个leftmax和一个rightmax，两者之间最小的代表了木桶最短的板，用最小的一个减去这个点的值可以得到这个点的水量。</p><p>我们比较朴素的思路是使用两个数组记录每一个点的leftmax数组和rightmax数组，最后进行累加计算。</p><p>实际上可以使用双指针，两个指针left，right来跟踪记录更新leftmax，rightmax值。随着指针移动，更新水量。之所以能这样跟踪，因为我们知道leftmax随着下标增加递增，rightmax随着下标减小递增。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lm = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> rm = height[height.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> sm = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            lm = Math.max(lm,height[left]);</span><br><span class="line">            rm = Math.max(rm,height[right]);</span><br><span class="line">            <span class="keyword">if</span>(lm&lt;rm)&#123;</span><br><span class="line">                sm += lm-height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sm += rm-height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> sm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用单调栈解决这个问题</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/hot-%E5%8F%8C%E6%8C%87%E9%92%88/">hot/双指针</category>
      
      
      
      <comments>http://example.com/2024/03/19/%E5%8A%9B%E6%89%A3/%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>匿名内部类以及衍生操作</title>
      <link>http://example.com/2024/03/19/Java/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/</link>
      <guid>http://example.com/2024/03/19/Java/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/</guid>
      <pubDate>Tue, 19 Mar 2024 01:52:12 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;匿名内部类&quot;&gt;匿名内部类&lt;/h2&gt;
&lt;p&gt;正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。&lt;/p&gt;
&lt;p&gt;而我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象：&lt;/p&gt;
&lt;figure c</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="匿名内部类">匿名内部类</h2><p>正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。</p><p>而我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student() &#123;</span><br><span class="line">    <span class="keyword">int</span> a;   <span class="comment">//因为本质上就相当于是子类，所以说子类定义一些子类的属性完全没问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;我是匿名内部类的实现!&quot;</span>);   <span class="comment">//直接使用父类中的name变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    student.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，接口也可以通过这种匿名内部类的形式，直接创建一个匿名的接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Study study = <span class="keyword">new</span> Study() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是学习方法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    study.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是说只有抽象类和接口才可以像这样创建匿名内部类，普通的类也可以，只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。</p><h2 id="lambda表达式">Lambda表达式</h2><p>特别的，<strong>如果一个接口中有且只有一个待实现的抽象方法</strong>，那么我们可以将匿名内部类简写为Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Study study = () -&gt; System.out.println(<span class="string">&quot;我是学习方法！&quot;</span>);   <span class="comment">//是不是感觉非常简洁！</span></span><br><span class="line">  study.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式：</p><ul><li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; &#123; 代码语句，包括返回值 &#125;</code></li><li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li><li>接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）</li></ul><p>注意，如果方法体中只有一个返回语句，可以直接省去花括号和<code>return</code>关键字，如果参数只有一个，那么可以省去小括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Study study = (a) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;今天学会了&quot;</span>+a;   <span class="comment">//这种情况是可以简化的</span></span><br><span class="line">&#125;;</span><br><span class="line">Study study = a -&gt; <span class="string">&quot;今天学会了&quot;</span>+a;</span><br></pre></td></tr></table></figure><p>如果一个方法的参数需要的是一个接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test(a -&gt; <span class="string">&quot;今天学会了&quot;</span>+a);   <span class="comment">//参数直接写成lambda表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Study study)</span></span>&#123;</span><br><span class="line">    study.study(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法引用">方法引用</h2><p>方法引用就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义得一样才行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Study</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;   <span class="comment">//待实现的求和方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Study study = (a, b) -&gt; a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Integer类中默认提供了求两个<span class="keyword">int</span>值之和的方法：</span><br><span class="line"><span class="comment">//Integer类中就已经有对应的实现了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Study study = (a, b) -&gt; Integer.sum(a, b);   <span class="comment">//直接使用Integer为我们通过好的求和方法</span></span><br><span class="line">    System.out.println(study.sum(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Study study = Integer::sum;    <span class="comment">//使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式</span></span><br><span class="line">    System.out.println(study.sum(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。任何方法都可以通过方法引用作为实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Study</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Main main = <span class="keyword">new</span> Main();</span><br><span class="line">    Study study = main::lbwnb;   <span class="comment">//成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lbwnb</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;卡布奇诺今犹在，不见当年倒茶人。&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双括号初始化">双括号初始化</h2><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">    put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;吴仙杰&quot;</span>);</span><br><span class="line">    put(<span class="string">&quot;englishName&quot;</span>, <span class="string">&quot;Jason Wu&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure><p>解释：</p><p>第一个括号是<strong>匿名内部类</strong>，第二个括号是<strong>实例初始化块</strong>。</p><p><strong>实例初始化块：</strong> 实例初始化块（instance initializerblock）是 Java中一种特殊的代码块，它用于在创建对象时执行初始化操作。实例初始化块使用一对花括号<code>&#123;&#125;</code> 包围，在类中定义，但没有使用 <code>static</code>修饰符。</p><p>实例初始化块在对象创建时执行，每次创建对象时都会执行一次。它在构造函数之前执行，因此可以用来对所有对象共享的初始化操作，而不用在每个构造函数中都重复编写。实例初始化块在构造函数之前执行，这意味着它可以用来初始化对象的实例变量，在构造函数中可以直接使用这些实例变量。</p><p>总结下关于静态初始化块、实例初始化块和构造函数三者的比较：</p><ul><li>执行顺序：静态初始化块 → 实例初始化块 → 构造函数</li><li>执行阶段：静态初始化块在类初始化阶段执行。实例初始化块和构造函数在对象实例化阶段执行</li><li>执行次数：不论实例化多少个对象，静态初始化块都只执行一次。实例化几个对象，就执行几次实例初始化块和构造函数</li></ul><p>实际相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wuxianjiezh.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 局部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalClass</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">            <span class="comment">// 实例初始化块</span></span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;吴仙杰&quot;</span>);</span><br><span class="line">                put(<span class="string">&quot;englishName&quot;</span>, <span class="string">&quot;Jason Wu&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> LocalClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式接口">函数式接口</h2><p>举例一个：<strong>Consumer消费型函数式接口：</strong>这个接口专门用于消费某个对象的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;    <span class="comment">//这个方法就是用于消费的，没有返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;   <span class="comment">//这个方法便于我们连续使用此消费接口</span></span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//专门消费Student对象的Consumer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Consumer&lt;Student&gt; STUDENT_CONSUMER = student -&gt; System.out.println(student+<span class="string">&quot; 真好吃！&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    STUDENT_CONSUMER.accept(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>andThen</code>方法继续调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    STUDENT_CONSUMER   <span class="comment">//我们可以提前将消费之后的操作以同样的方式预定好</span></span><br><span class="line">            .andThen(stu -&gt; System.out.println(<span class="string">&quot;我是吃完之后的操作！&quot;</span>)) </span><br><span class="line">            .andThen(stu -&gt; System.out.println(<span class="string">&quot;好了好了，吃饱了！&quot;</span>))</span><br><span class="line">            .accept(student);   <span class="comment">//预定好之后，再执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分代码实现逻辑：</p><p>c1.andThen（after2）.accept(student),</p><p>变成{c1.accept(student),after2.accept(student)}</p><p>c1.accept(student):=c.andThen(after1).accept(student)</p><p>变成{c.accept(student),after1.accept(student)}</p><p>最后变成实现流程为：</p><p>c.accept(student)</p><p>after1.accept(student)</p><p>after2.accept(student)</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      
      <comments>http://example.com/2024/03/19/Java/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>http://example.com/2024/03/15/%E4%BD%9C%E4%B8%9A/%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/</link>
      <guid>http://example.com/2024/03/15/%E4%BD%9C%E4%B8%9A/%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/</guid>
      <pubDate>Fri, 15 Mar 2024 01:37:21 GMT</pubDate>
      
        
        
      <description>&lt;h2 align=&quot;center&quot;&gt;
专题文献检索
&lt;/h2&gt;
&lt;h3 id=&quot;专题检索&quot;&gt;1 专题检索&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;研究方向：&lt;/strong&gt;医学图像分割&lt;/p&gt;
&lt;center&gt;
表 1 检索要素
&lt;/center&gt;
&lt;table&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 align="center">专题文献检索</h2><h3 id="专题检索">1 专题检索</h3><p><strong>研究方向：</strong>医学图像分割</p><center>表 1 检索要素</center><table><colgroup><col style="width: 9%"><col style="width: 57%"><col style="width: 32%"></colgroup><thead><tr class="header"><th>检索要素</th><th>检索要素1</th><th>检索要素2</th></tr></thead><tbody><tr class="odd"><td>中文相关词</td><td>医学图像；医学影像</td><td>分割;语义分割</td></tr><tr class="even"><td>外文相关词</td><td>medical imaging;medical image;medical images;doctored image;medicineimage;medical imagings;</td><td>segmentation;semantic segmentation</td></tr></tbody></table><center>表 2 检索式及检索结果</center><table><colgroup><col style="width: 11%"><col style="width: 64%"><col style="width: 10%"><col style="width: 12%"></colgroup><thead><tr class="header"><th>数据库名称</th><th>检索式</th><th>命中记录数</th><th>检索效果评价</th></tr></thead><tbody><tr class="odd"><td>知网</td><td>(医学图像 + 医学影像) * (分割 + 语义分割)</td><td>7304</td><td>检索效果较好</td></tr><tr class="even"><td>WOS核心合集</td><td>("medical image" or "medical imaging" or "medical images" or"medical imagings" or "medicine image" or "doctored image") and("segmentation" or "semantic segmentation")</td><td>14333</td><td>相关度高</td></tr><tr class="odd"><td>EV</td><td>("medical image" or "medical imaging" or "medical images" or"medical imagings" or "medicine image" or "doctored image") and("segmentation" or "semantic segmentation")</td><td>36991</td><td>全面较杂</td></tr><tr class="even"><td>IEL</td><td>("medical image" OR "medical imaging" OR "medical images" OR"medical imagings" OR "medicine image" OR "doctored image") AND("segmentation" OR "semantic segmentation")</td><td>11376</td><td>精炼全面</td></tr></tbody></table><h3 id="筛选文献">2 筛选文献</h3><p><strong>筛选文献依据：</strong>首先由于是深度学习领域，知识更新迭代较快，我们选择2022年以后的文献，同时勾选开放获取，高被引论文。但是我们不想看综述，所以排除综述。</p><p>[1]HUANG Y, YANG H, SUN K, 等. InterFormer: Real-time InteractiveImage Segmentation[M/OL]. arXiv, 2023[2024-03-05].http://arxiv.org/abs/2304.02942.</p><p>[2]Butoi V I, Ortiz J J G, Ma T, et al. Universeg: Universal medicalimage segmentation[C]//Proceedings of the IEEE/CVF InternationalConference on Computer Vision. 2023: 21438-21451.</p><p>[3]Wu J, Fu R, Fang H, et al. Medsegdiff: Medical image segmentationwith diffusion probabilistic model[C]//Medical Imaging with DeepLearning. PMLR, 2024: 1623-1639.</p><p>[4]Wu J, Fu R, Fang H, et al. Medical sam adapter: Adapting segmentanything model for medical image segmentation[J]. arXiv preprintarXiv:2304.12620, 2023.</p><p>[5]Zhang K, Liu D. Customized segment anything model for medicalimage segmentation[J]. arXiv preprint arXiv:2304.13785, 2023.</p><p>[6]He S, Bao R, Li J, et al. Accuracy of segment-anything model (sam)in medical image segmentation tasks[J]. arXiv preprint arXiv:2304.09324,2023.</p><p>[7]Zhang Y, Zhou T, Wang S, et al. Input augmentation with sam:Boosting medical image segmentation with segmentation foundationmodel[C]//International Conference on Medical Image Computing andComputer-Assisted Intervention. Cham: Springer Nature Switzerland, 2023:129-139.</p><p>[8]Xu G, Zhang X, He X, et al. Levit-unet: Make faster encoders withtransformer for medical image segmentation[C]//Chinese Conference onPattern Recognition and Computer Vision (PRCV). Singapore: SpringerNature Singapore, 2023: 42-53.</p><p>[9]Xu G, Zhang X, He X, et al. Levit-unet: Make faster encoders withtransformer for medical image segmentation[C]//Chinese Conference onPattern Recognition and Computer Vision (PRCV). Singapore: SpringerNature Singapore, 2023: 42-53.</p><p>[10]You C, Dai W, Min Y, et al. Rethinking semi-supervised medicalimage segmentation: A variance-reduction perspective[J]. Advances inNeural Information Processing Systems, 2024, 36.</p><p>[11]Zhang Y, Jiao R. How segment anything model (SAM) boost medicalimage segmentation?[J]. arXiv preprint arXiv:2305.03678, 2023.</p><p>[12]Zhang H, Zhong X, Li G, et al. BCU-Net: Bridging ConvNeXt andU-Net for medical image segmentation[J]. Computers in Biology andMedicine, 2023, 159: 106960.</p><p>[13]Ulrich C, Isensee F, Wald T, et al. Multitalent: A multi-datasetapproach to medical image segmentation[C]//International Conference onMedical Image Computing and Computer-Assisted Intervention. Cham:Springer Nature Switzerland, 2023: 648-658.</p><p>[14]Heidari M, Kazerouni A, Soltany M, et al. Hiformer: Hierarchicalmulti-scale representations using transformers for medical imagesegmentation[C]//Proceedings of the IEEE/CVF winter conference onapplications of computer vision. 2023: 6202-6212.</p><p>[15]Li Z, Li Y, Li Q, et al. Lvit: language meets vision transformerin medical image segmentation[J]. IEEE transactions on medical imaging,2023.</p><p>[16]Wang Y, Xiao B, Bi X, et al. Mcf: Mutual correction framework forsemi-supervised medical image segmentation[C]//Proceedings of theIEEE/CVF conference on computer vision and pattern recognition. 2023:15651-15660.</p><p>[17]Yin Y, Han Z, Jian M, et al. AMSUnet: A neural network usingatrous multi-scale convolution for medical image segmentation[J].Computers in Biology and Medicine, 2023, 162: 107120.</p><p>[18]Wang G, Luo X, Gu R, et al. PyMIC: A deep learning toolkit forannotation-efficient medical image segmentation[J]. Computer Methods andPrograms in Biomedicine, 2023, 231: 107398.</p><p>[19]Shen T, Xu H. Medical image segmentation based on Transformer andHarDNet structures[J]. IEEE Access, 2023, 11: 16621-16630.</p><p>[20]Zhang S, Zhang J, Tian B, et al. Multi-modal contrastive mutuallearning and pseudo-label re-learning for semi-supervised medical imagesegmentation[J]. Medical Image Analysis, 2023, 83: 102656.</p><h3 id="创建定题跟踪">3 创建定题跟踪</h3><p>定题跟踪服务是根据用户特定研究课题的需要，在该课题研究的整个过程中，定期或不定期地连续为用户提供文献信息的全程文献检索服务，并及时反馈最新检索结果，便于用户随时跟踪自己教学或研究课题或本行业的最新发展动态。</p><p><strong>流程：</strong></p><ol type="1"><li><p>首先我们根据检索式检索需要的文献，然后点击创建跟踪服务<img src="file:///D:\QQ%20Cahes\2320109962\Image\C2C\TUL_9CU%5DJH98D03XDSF%5DX_R.png" alt="img"></p></li><li><p>输入名称，勾选发送电子邮件服务</p><p><img src="file:///D:\QQ Cahes\2320109962\Image\C2C\[QNF5TUHHVZA]SB[2SW~~ZM.png" alt="img" style="zoom: 50%;"></p></li><li><p>成功创建跟踪</p><p><img src="/2024/03/15/%E4%BD%9C%E4%B8%9A/%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/IDM下载\Documents\1.png" alt="1" style="zoom:50%;"></p></li><li><p>管理跟踪服务</p></li></ol><p><img src="/2024/03/15/%E4%BD%9C%E4%B8%9A/%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/IDM下载\Documents\2.png" alt="2" style="zoom:50%;"></p>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2024/03/15/%E4%BD%9C%E4%B8%9A/%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>三数和为0</title>
      <link>http://example.com/2024/03/13/%E5%8A%9B%E6%89%A3/%E5%8F%8C%E6%8C%87%E9%92%88/%E4%B8%89%E5%85%83%E5%92%8C/</link>
      <guid>http://example.com/2024/03/13/%E5%8A%9B%E6%89%A3/%E5%8F%8C%E6%8C%87%E9%92%88/%E4%B8%89%E5%85%83%E5%92%8C/</guid>
      <pubDate>Wed, 13 Mar 2024 03:09:49 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;-4，-1，-1，0，1，2&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</description>
        
      
      
      
      <content:encoded><![CDATA[<p>-4，-1，-1，0，1，2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        Arrys.sort(nums);</span><br><span class="line">        int left = 0,right = nums.length-1;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ep = new new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(i == 0)&#123;left = 1;&#125;</span><br><span class="line">            if(i == nums.length-1)&#123;right = nums.length-2;&#125;</span><br><span class="line">            while(left&lt;right)&#123;</span><br><span class="line">                if(nums[i]+nums[left]+nums[right]&lt;0)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;else(nums[i]+nums[left]+nums[right]&gt;0)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    List&lt;Integer&gt; ap = new ArrayList&lt;&gt;();</span><br><span class="line">                    ap.add(nums[left]);</span><br><span class="line">                    ap.add(nums[i]);</span><br><span class="line">                    ap.add(nums[right]);</span><br><span class="line">                    ep.add(ap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/hot-%E5%8F%8C%E6%8C%87%E9%92%88/">hot/双指针</category>
      
      
      
      <comments>http://example.com/2024/03/13/%E5%8A%9B%E6%89%A3/%E5%8F%8C%E6%8C%87%E9%92%88/%E4%B8%89%E5%85%83%E5%92%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>盛最多的水</title>
      <link>http://example.com/2024/03/12/%E5%8A%9B%E6%89%A3/%E5%8F%8C%E6%8C%87%E9%92%88/%E7%9B%9B%E6%9C%80%E5%A4%9A%E7%9A%84%E6%B0%B4/</link>
      <guid>http://example.com/2024/03/12/%E5%8A%9B%E6%89%A3/%E5%8F%8C%E6%8C%87%E9%92%88/%E7%9B%9B%E6%9C%80%E5%A4%9A%E7%9A%84%E6%B0%B4/</guid>
      <pubDate>Tue, 12 Mar 2024 12:57:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;给定一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;height&lt;/code&gt; 。有
&lt;code&gt;n&lt;/code&gt; 条垂线，第 &lt;code&gt;i&lt;/code&gt; 条线的两个端点是
&lt;code&gt;(i, 0)&lt;/code&gt; 和 &lt;code&gt;(i, height</description>
        
      
      
      
      <content:encoded><![CDATA[<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有<code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是<code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code>轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p>输入：2,5,4,8,3</p><p>输出：10</p><h2 id="思路">思路：</h2><p>木桶效应，取决最短的板，也就是我们两个指针一个最左一个最右，我们移动短的（低的）那一个指针，假如我们移动一下，如果被移动的指针指向了一个更低的值那我们是赚了，因为一开始的下标差大，同时高度值也一样。如果指向了一个更高的值，那下标差会变小，我们只需要进行比较就行，总之稳赚不亏。为什么移动更低的，因为低的决定了装水的量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">                max = Math.max(max,(right-left)*Math.min(height[left],height[right]));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max = Math.max(max,(right-left)*Math.min(height[left],height[right]));</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针每个指针移动要有依据</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/hot-%E5%8F%8C%E6%8C%87%E9%92%88/">hot/双指针</category>
      
      
      
      <comments>http://example.com/2024/03/12/%E5%8A%9B%E6%89%A3/%E5%8F%8C%E6%8C%87%E9%92%88/%E7%9B%9B%E6%9C%80%E5%A4%9A%E7%9A%84%E6%B0%B4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>常用函数</title>
      <link>http://example.com/2024/03/12/%E5%8A%9B%E6%89%A3/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link>
      <guid>http://example.com/2024/03/12/%E5%8A%9B%E6%89%A3/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid>
      <pubDate>Tue, 12 Mar 2024 12:35:42 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;交换数组中两个数字&quot;&gt;交换数组中两个数字&lt;/h2&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="交换数组中两个数字">交换数组中两个数字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">    nums[left] = nums[right];</span><br><span class="line">    nums[right] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆转数组">逆转数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>；</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">tmp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = tmp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%8A%9B%E6%89%A3/">力扣</category>
      
      
      
      <comments>http://example.com/2024/03/12/%E5%8A%9B%E6%89%A3/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
