<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Erin枫</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>来者犹可追</description>
    <pubDate>Mon, 08 Nov 2021 15:25:14 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>类</title>
      <link>http://example.com/2021/11/08/Java/%E7%AC%AC%E4%B8%89%E7%AB%A0/</link>
      <guid>http://example.com/2021/11/08/Java/%E7%AC%AC%E4%B8%89%E7%AB%A0/</guid>
      <pubDate>Mon, 08 Nov 2021 11:41:16 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h1&gt;&lt;p&gt;类相当于是对象的模板，可以认为对象就是实例。&lt;/p&gt;
&lt;p&gt;也可以像下面这样理解？&lt;/p&gt;
&lt;figure class=&quot;h</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类相当于是对象的模板，可以认为对象就是实例。</p><p>也可以像下面这样理解？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类 对象;<span class="comment">//这里的相当于对象</span></span><br><span class="line">对象 = <span class="keyword">new</span> 类的构造方法([参数列表]);<span class="comment">//分配了内存空间以后才是一个实例</span></span><br></pre></td></tr></table></figure><p><strong>类（class）</strong>是既包括数据又包括作用于数据的一组操作的 封装体。类可以看成是一类相似对象的模板！类具有封装性、 继承性、多态性和抽象性。</p><p><strong>对象（object）</strong>是类的具体<strong>实例（instance）</strong>。Java中， 万事万物皆对象！！！Java中通过引用操作对象！引用就 是指向对象的内存中地址！！</p><h1 id="类的变量和方法"><a href="#类的变量和方法" class="headerlink" title="类的变量和方法"></a>类的变量和方法</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>在类中，用static声明的成员变量为静态成员变量，它为该类的公用变量、属于类，被 该类的所有实例共享，在类被载入时被显示初始化；对于该类的所有对象来说，static成员变量只有一份；可以使用 “对象.类属性”来调用，不过，一般都是用”类名.类属性”；static变量置于方法区中）。<strong>局部变量</strong>使用前必须要<strong>先赋值</strong>、而<strong>实例变量</strong>则有<strong>缺省初值</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">22</span>;<span class="comment">//类变量</span></span><br><span class="line">    String name = <span class="string">&quot;张三&quot;</span>;<span class="comment">//实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>局部变量：</strong></p><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li><strong>访问修饰符不能用于局部变量；</strong></li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul><p><strong>实例变量：</strong></p><ul><li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>访问修饰符可以修饰实例变量；</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li></ul><p><strong>类变量(静态变量)：</strong></p><ul><li>类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。</li><li>无论一个类创建了多少个对象，<strong>类只拥有类变量的一份拷贝。</strong></li><li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li><li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li><li>静态变量在程序开始时创建，在程序结束时销毁。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li><li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li><li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>定义格式：<code>[修饰符] 方法返回值类型 方法名(形参列表) &#123; // n条语句 &#125;</code></p><h1 id="类的封装性"><a href="#类的封装性" class="headerlink" title="类的封装性"></a>类的封装性</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法，又称为<strong>构造器Constructor</strong>，用于构造该类的实例。<strong>返回值类型</strong>为该类本身。</p><p>如果我们没有定义构造器，系统自动会定义一个无参的构造器，如果已定义则编译器不会添加；构造器的方法名必须和类名一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明及调用构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> </span></span><br><span class="line"><span class="class"></span>&#123; <span class="function"><span class="keyword">public</span> <span class="title">MyDate</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        year = y;</span><br><span class="line">        month = m;</span><br><span class="line">        day = d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyDate d = <span class="keyword">new</span> MyDate(<span class="number">2009</span>,<span class="number">7</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyDate</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>方法的<strong>重载</strong>overload。方法的重载是指一个类中可以定义有相同的名字， 但参数不同的多个方法。调用时，会根据不同的参数列表选择对应的方法。</p><p><strong>重载</strong>：同一个类，同一个方法名，不同的参数列表（类型、个数、顺序不同）</p><ul><li><p>只有返回值不同不构成方法的重载。 </p></li><li><p>只有形参的名称不同，不构成方法的重载。</p></li><li><p>构造方法与普通方法一样也可以重载。</p></li></ul><h2 id="对象的引用和运算"><a href="#对象的引用和运算" class="headerlink" title="对象的引用和运算"></a>对象的引用和运算</h2><h3 id="this引用"><a href="#this引用" class="headerlink" title="this引用"></a>this引用</h3><ul><li>指代对象本身</li><li>访问本类的成员变量和成员方法</li><li>调用<strong>本类重载的构造方法</strong></li><li>普通方法中，this总是指向调用该方法的对象；</li><li>构造方法中，this总是指向正要初始化的对象；</li><li>this<strong>不能用于static</strong>方法；</li><li>可以在一个构造方法中通过this调用其它构造方法，且<strong>必须是构造方法中的第一条语句</strong>。</li><li>this只能用在方法中，其的本质是“<strong>调用该方法的创建好的对象的地址</strong>”。由于在 构造方法调用时，对象已经创建。因此，在构造方法中也可以使用this代表“当前 对象”。</li></ul><h3 id="instanceof运算"><a href="#instanceof运算" class="headerlink" title="instanceof运算"></a>instanceof运算</h3><p>instanceof 运算符 用于：判断 该运算符前面引用类型变量指向的对象是否是后面类，或者其子类、接口实现类创建的对象。如果是则返回true，否则返回false</p><h2 id="隐藏-封装"><a href="#隐藏-封装" class="headerlink" title="隐藏/封装"></a>隐藏/封装</h2><p><strong>类的访问权限：</strong>public和缺省</p><p><strong>类中成员的访问权限：</strong></p><div class="table-container"><table><thead><tr><th>权限修饰符</th><th>同一类</th><th>同一包</th><th>不同包的子类</th><th>所有类</th></tr></thead><tbody><tr><td>public(公有)</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected(受保护的)</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>缺省</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>private(私有)</td><td>√</td><td></td><td></td></tr></tbody></table></div><p><strong>静态成员变量：</strong>在类中，用static声明的成员变量为静态成员变量，或叫做类属 性、类变量。它为该类的公用变量，属于类，被该类的所有实例共享（只此一 份），在类被载入时被显式初始化。可以使用“对象.类属性”来调用，不过一般 都使用“类名.类属性”。static变量置于方法区</p><p><strong>静态方法：</strong>在类中，用static声明的成员变量为静态成员变量，或叫做类属 性、类变量。它为该类的公用变量，属于类，被该类的所有实例共享（只此一 份），在类被载入时被显式初始化。可以使用“对象.类属性”来调用，不过一般 都使用“类名.类属性”。static变量置于方法区</p><p><strong>静态初始化块 static {}：</strong>如果希望加载后，对整个类进行某些初始化操作，可 以使用static初始化，</p><ul><li>是在类初始化时执行，不是在创建对象时执行。</li><li>静态初始化块中不能访问非static成员变量。</li><li>执行顺序：上溯到Object类，先执行Object的静态初始化块，再向下执行子 类的静态初始化块，直到我们的类的静态初始化块为止。</li></ul><h1 id="类的继承性"><a href="#类的继承性" class="headerlink" title="类的继承性"></a>类的继承性</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>基于一个已存在的类，创建一个新的类。已存在的类即父类，新的类即子类，继承就是子类继承并拥有父类的属性和方法，同时，子类还有拥有父类所不具有的属性和方法。</p><p>父类，也称为基类、超类（superclass）；子类，也称为派生类。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul><li>子类继承父类的成员变量</li><li>子类继承父类除构造方法以外的成员方法</li><li>子类不能继承父类的构造方法</li><li>子类可以增加成员，可以重定义从父类继承来的 成员，但不能删除它们。</li></ul><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Object</span><span class="params">()</span> <span class="comment">//构造方法</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> <span class="comment">//描述对象</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//比较对象相等</span></span></span><br><span class="line"><span class="function">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>Java中的类都是Object的子类</p><h2 id="子类对父类成员的访问权限"><a href="#子类对父类成员的访问权限" class="headerlink" title="子类对父类成员的访问权限"></a>子类对父类成员的访问权限</h2><ul><li>子类不能访问父类的私有成员（private）</li><li>子类能够访问父类的公有成员（public）和保护成员（protected）。</li><li>子类对父类的缺省权限成员的访问控制，以包为界分两种情况，可以访问当前包中成员</li></ul><h2 id="子类的构造方法"><a href="#子类的构造方法" class="headerlink" title="子类的构造方法"></a>子类的构造方法</h2><p>使用super()调用父类构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>([参数列表])</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, MyDate birthday, String spec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, birthday); <span class="comment">//调用父类同参数的构造方法</span></span><br><span class="line">    <span class="keyword">this</span>.speciality = spec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认执行super()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> <span class="comment">//Java提供的默认构造方法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">//调用父类构造方法Person()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="super引用"><a href="#super引用" class="headerlink" title="super引用"></a>super引用</h2><ul><li>调用父类的构造方法。<code>super([参数列表])</code></li><li>引用父类同名成员。<code>super.成员变量</code>，<code>super.成员方法([参数列表])</code></li><li>super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方 法或属性。</li></ul><h1 id="类的抽象性"><a href="#类的抽象性" class="headerlink" title="类的抽象性"></a>类的抽象性</h1><ul><li>有抽象方法的类只能定义成抽象类。</li><li>抽象类不能实例化，即不能用new来实例化抽象类。</li><li>抽象类只能用来继承。</li><li>抽象类可以包含属性、方法、构造方法（抽象类除了抽象方法，也可以定义普通方法、 构造方法和普通属性）。但是构造方法不能用来new实例，只能用来被子类调用。</li><li>抽象方法只有方法的声明，没有方法体（即{}和里面的代码），其必须被子类实现 （这也是抽象方法的设计初衷，提供规范，要求各子类实现规范）</li><li>抽象类用于设计和实现的分离，但是这种分离不够彻底。</li><li>一个抽象类可以继承另一个抽象类</li><li>有抽象方法的类一定是抽象类，但是抽象类中不一定都是抽象方法，也可以全部都是具 体方法</li></ul><p><strong>特点：</strong></p><ul><li>构造方法、静态成员方法不能被声明为抽象方法。</li><li>一个非抽象类必须实现从父类继承来的所有抽象方法</li><li>不能创建抽象类的实例。</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java/">Java</category>
      
      
      
      <comments>http://example.com/2021/11/08/Java/%E7%AC%AC%E4%B8%89%E7%AB%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>parameter,defparame,`define,localparam四者区别</title>
      <link>http://example.com/2021/11/07/Verilog/parameter/</link>
      <guid>http://example.com/2021/11/07/Verilog/parameter/</guid>
      <pubDate>Sun, 07 Nov 2021 09:02:40 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;figure class=&quot;highlight verilog&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span>:    作用 -&gt; 常用于定义常量可以跨模块、跨文件;</span></span><br><span class="line">            范围 -&gt; 整个工程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span>:  作用 -&gt; 常用于模块间参数传递;</span><br><span class="line">            范围 -&gt; 本<span class="keyword">module</span>内有效的定义;</span><br><span class="line"></span><br><span class="line"><span class="keyword">localparam</span>: 作用 -&gt; 常用于状态机的参数定义;</span><br><span class="line">            范围 -&gt; 本<span class="keyword">module</span>内有效的定义，不可用于参数传递;</span><br><span class="line"><span class="keyword">localparam</span> cannot be used <span class="keyword">within</span> the <span class="keyword">module</span> port <span class="keyword">parameter</span> list.</span><br></pre></td></tr></table></figure><h2 id="Parameter"><a href="#Parameter" class="headerlink" title="Parameter"></a>Parameter</h2><p>可以放在模块头上也可以放在模块的内部，他可以通过defparameter的方式或者模块实例化的时候进行重写。</p><p><strong>Example：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo</span><br><span class="line">#(<span class="keyword">parameter</span> MSB=<span class="number">3</span>, LSB=<span class="number">0</span>, DEPTH=<span class="number">4</span>)<span class="comment">//可以被重写</span></span><br><span class="line"> (port_list );</span><br><span class="line"> item;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo</span><br><span class="line"> (port_list );</span><br><span class="line"> <span class="keyword">parameter</span> MSB=<span class="number">3</span>, LSB=<span class="number">0</span>, DEPTH=<span class="number">4</span><span class="comment">//可以被重写</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>一旦有模块参数被写在模块头部，则出现在模块内部的模块参数被视为本地参数，不能被重写。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo</span><br><span class="line"> #(<span class="keyword">parameter</span> MSB=<span class="number">3</span>, LSB=<span class="number">0</span>)<span class="comment">//可以被重写</span></span><br><span class="line"> (port_list );</span><br><span class="line"><span class="keyword">parameter</span> DEPTH=<span class="number">4</span>; <span class="comment">//不能被重写</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>在上层模块对参数重写的方式如下:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)F1<span class="variable">.MSB</span>=<span class="number">4</span>;F1<span class="variable">.LSB</span>=<span class="number">2</span>;fifo F1;</span><br><span class="line"><span class="number">2</span>) fifo <span class="variable">#(4,2) F1(port_list)</span>;</span><br><span class="line"><span class="number">3</span>) fifo <span class="variable">#(.LSB(2), .MSB(4)) fifo(port_list)</span>;</span><br></pre></td></tr></table></figure><h2 id="defparam修改参数"><a href="#defparam修改参数" class="headerlink" title="defparam修改参数"></a>defparam修改参数</h2><p>当一个模块引用另外一个模块时，高层模块可以改变低层模块用parameter定义的参数值。例子代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Top(...);<span class="comment">//这是一个顶层模块</span></span><br><span class="line">    <span class="keyword">defparam</span>    U_D1<span class="variable">.Width</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">defparam</span>    U_D1<span class="variable">.Polarity</span> = <span class="number">0</span>;<span class="comment">//使得U_D1的Width = 4， Polarity = 0；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defparam</span>    U_D2<span class="variable">.Width</span> = <span class="number">5</span>;<span class="comment">//使得U_D2的Width = 5，Polarity 不变，即为1；</span></span><br><span class="line">    Decode U_D1();</span><br><span class="line">    Decode U_D2(); </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Decode(A,F);    <span class="comment">//这是一个子模块</span></span><br><span class="line">    <span class="keyword">parameter</span> Width = <span class="number">1</span>, Polarity = <span class="number">1</span>;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>也可以模块实例化的时候进行修改，代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Top(...);<span class="comment">//这是一个顶层模块</span></span><br><span class="line">    Decode <span class="variable">#(4,0) U_D1()</span>; <span class="comment">//使得Width = 4， Polarity = 0；</span></span><br><span class="line">    Decode <span class="variable">#(5) U_D2()</span>; <span class="comment">//使得 Width = 5，Polarity 不变，即为1；</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Decode(A,F);    <span class="comment">//这是一个子模块</span></span><br><span class="line">    <span class="keyword">parameter</span> Width = <span class="number">1</span>, Polarity = <span class="number">1</span>;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="define"><a href="#define" class="headerlink" title="`define"></a>`define</h2><p><strong>概念：</strong>可以跨模块的定义，写在模块名称上面，在整个设计工程都有效。一旦define指令被编译，其在整个编译过程中都有效。例如，通<br>过另一个文件中的define指令，定义的常量可以被其他文件调用,直到遇到undef；</p><p><strong>举例：</strong>定义 define UART_CNT 10’d1024.使用UART_CNT</p><h2 id="localparam："><a href="#localparam：" class="headerlink" title="localparam："></a>localparam：</h2><p><strong>概念：</strong>本module内有效的定义，不可用于参数传递；localparamcannot be used within the module port parameter list.一般情况下，状态机的参数都是用localparam的。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Verilog/">Verilog</category>
      
      
      
      <comments>http://example.com/2021/11/07/Verilog/parameter/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>时域卷积频域相乘</title>
      <link>http://example.com/2021/11/07/%E4%BF%A1%E5%8F%B7/%E6%97%B6%E5%9F%9F%E5%8D%B7%E7%A7%AF%E9%A2%91%E5%9F%9F%E7%9B%B8%E4%B9%98/</link>
      <guid>http://example.com/2021/11/07/%E4%BF%A1%E5%8F%B7/%E6%97%B6%E5%9F%9F%E5%8D%B7%E7%A7%AF%E9%A2%91%E5%9F%9F%E7%9B%B8%E4%B9%98/</guid>
      <pubDate>Sun, 07 Nov 2021 07:33:57 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;为什么时域卷积频域就是相乘&quot;&gt;&lt;a href=&quot;#为什么时域卷积频域就是相乘&quot; class=&quot;headerlink&quot; title=&quot;为什么时域卷积频域就是相乘&quot;&gt;&lt;/a&gt;为什么时域卷积频域就是相乘&lt;/h2&gt;&lt;p&gt;​    一般教科书都是选择理论证明，但是如何直观去</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="为什么时域卷积频域就是相乘"><a href="#为什么时域卷积频域就是相乘" class="headerlink" title="为什么时域卷积频域就是相乘"></a>为什么时域卷积频域就是相乘</h2><p>​    一般教科书都是选择理论证明，但是如何直观去理解呢。我们知道一个信号可以傅里叶变换分解后然后变成很多个不同频率正弦信号。那个我们将两个信号去卷积，正弦信号卷积分配，不同频率的正弦信号卷积后为0（“正交”），那么就是相同频率的正弦信号相卷积，频率不变，辐值相乘。这在频域上就表现为相乘。</p><p>​    从知乎上看到的，写的很好，分享一下</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E4%BF%A1%E5%8F%B7/">信号</category>
      
      
      
      <comments>http://example.com/2021/11/07/%E4%BF%A1%E5%8F%B7/%E6%97%B6%E5%9F%9F%E5%8D%B7%E7%A7%AF%E9%A2%91%E5%9F%9F%E7%9B%B8%E4%B9%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Testbench文件编写方法</title>
      <link>http://example.com/2021/11/07/Verilog/Testbench%E6%96%87%E4%BB%B6%E8%AF%BB%E6%B3%95%E5%92%8C%E5%86%99%E6%B3%95/</link>
      <guid>http://example.com/2021/11/07/Verilog/Testbench%E6%96%87%E4%BB%B6%E8%AF%BB%E6%B3%95%E5%92%8C%E5%86%99%E6%B3%95/</guid>
      <pubDate>Sun, 07 Nov 2021 07:22:45 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;转载：&lt;a href=&quot;https://blog.csdn.net/weixin_46423500/article/details/113264878&quot;&gt;https://blog.csdn.net/weixin_46423500/article/details/113264</description>
        
      
      
      
      <content:encoded><![CDATA[<p>转载：<a href="https://blog.csdn.net/weixin_46423500/article/details/113264878">https://blog.csdn.net/weixin_46423500/article/details/113264878</a></p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>testbench文件基本结构：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 仿真单位/仿真精度</span></span><br><span class="line"><span class="keyword">module</span> test_bench();</span><br><span class="line"><span class="comment">//通常 testbench没有输入与输出端口</span></span><br><span class="line">信号或变量定义声明</span><br><span class="line">使用<span class="keyword">initial</span>或<span class="keyword">always</span>语句产生激励波形</span><br><span class="line">例化设计模块</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="声明仿真精度和仿真单位"><a href="#声明仿真精度和仿真单位" class="headerlink" title="声明仿真精度和仿真单位"></a>声明仿真精度和仿真单位</h3><p>/#(延时时间)，#(10ns)代表延时10ns</p><p>仿真精度就是说最低的延时精度，比如说<code>`timescale 1ns/1ns</code>，延时精度只能达到1ns</p><p>如果想要延时10.001ns，就要把仿真精度改成1ps(1ns = 1000ps)。</p><h3 id="定义模块名"><a href="#定义模块名" class="headerlink" title="定义模块名"></a>定义模块名</h3><p><code>module flow_led_tb();</code></p><p>模块名的命名方式一般在被测模块名后面加上“ _ tb”，或者在被测模块名前面加上“tb_”，表示为哪个模块提供激励测试文件，通常激励文件不需要定义输入和输出端口。</p><h3 id="信号或常量定义"><a href="#信号或常量定义" class="headerlink" title="信号或常量定义"></a>信号或常量定义</h3><p><strong>常量：</strong></p><p> 代码中定义的常量有时需要频繁的修改，为了方便修改，可以把常量定义成参数的形式，定义参数的关键字为parameter，代码如下：</p><p><code>parameter T = 20;</code></p><p><strong>变量：</strong></p><p>Verilog代码中，常用声明信号或变量的关键字为reg和wire，在initial语句或者always语句中使用的变量定义成reg类型，在assign语句或者用于连接被例化模块名的信号定义成wire类型，声明方法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reg define</span></span><br><span class="line"><span class="keyword">reg</span> sys_clk; <span class="comment">// 时钟信号</span></span><br><span class="line"><span class="keyword">reg</span> sys_rst_n; <span class="comment">// 复位信号</span></span><br><span class="line"><span class="comment">//wire define</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] led;</span><br></pre></td></tr></table></figure><p><strong>使用initial或always语句产生激励波形：</strong><br> 产生时钟激励。代码表示每10ns（假设仿真单位是1ns），sys_clk的电平状态翻转一次，由于一个完整的时钟周期包括一个高电平和一个低电平，因此sys_clk的时钟周期为20ns，占空比为50%。代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> #<span class="number">10</span> sys_clk = ~sys_clk;</span><br></pre></td></tr></table></figure><p>如果要生成其它占空比时钟的话，代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">#<span class="number">6</span> sys_clk = <span class="number">0</span>; #<span class="number">4</span> sys_clk = <span class="number">1</span>; <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在always语句中设置了sys_clk的时钟周期，并没有设置初始值，因此sys_clk需要在initial语句中进行初始化。代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"> sys_clk = <span class="number">1&#x27;b0</span>; <span class="comment">// 时钟初始值</span></span><br><span class="line">sys_rst_n = <span class="number">1&#x27;b0</span>; <span class="comment">// 复位初始值</span></span><br><span class="line"> #<span class="number">20</span> sys_rst_n = <span class="number">1&#x27;b1</span>; <span class="comment">// 在第21ns的时候复位信号信号拉高</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="例化设计模块"><a href="#例化设计模块" class="headerlink" title="例化设计模块"></a>例化设计模块</h3><p>例化的设计模块是指被测模块，例化被测模块的目的是把被测模块和激励模块实例化起来，并且把被测模块的端口与激励模块的端口进行相应的连接，使得激励可以输入到被测模块。如果被测模块是由多个模块组成的，激励模块中只需要例化多个模块的顶层模块，代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow_led u0_flow_led (</span><br><span class="line"> <span class="variable">.sys_clk</span> (sys_clk ),</span><br><span class="line"> <span class="variable">.sys_rst_n</span> (sys_rst_n),</span><br><span class="line"> <span class="variable">.led</span> (led )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="完整文件"><a href="#完整文件" class="headerlink" title="完整文件"></a>完整文件</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">`<span class="meta-keyword">timescale</span> 1ns/1ns // 定义仿真时间单位1ns和仿真时间精度为1ns</span></span><br><span class="line"> <span class="keyword">module</span> flow_led_tb(); <span class="comment">// 测试模块</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//parameter define</span></span><br><span class="line"><span class="keyword">parameter</span> T = <span class="number">20</span>; <span class="comment">// 时钟周期为20ns</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//reg define</span></span><br><span class="line"><span class="keyword">reg</span> sys_clk; <span class="comment">// 时钟信号</span></span><br><span class="line"> <span class="keyword">reg</span> sys_rst_n; <span class="comment">// 复位信号</span></span><br><span class="line"><span class="comment">//wire define</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] led;</span><br><span class="line"><span class="comment">//给输入信号初始值</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">sys_clk = <span class="number">1&#x27;b0</span>;</span><br><span class="line">sys_rst_n = <span class="number">1&#x27;b0</span>; <span class="comment">// 复位</span></span><br><span class="line"><span class="variable">#(T+1)</span> sys_rst_n = <span class="number">1&#x27;b1</span>; <span class="comment">// 在第21ns的时候复位信号信号拉高</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//50Mhz的时钟，周期则为1/50Mhz=20ns,所以每10ns，电平取反一次</span></span><br><span class="line"><span class="keyword">always</span> <span class="variable">#(T/2)</span> sys_clk = ~sys_clk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例化flow_led模块</span></span><br><span class="line">flow_led u0_flow_led (</span><br><span class="line"><span class="variable">.sys_clk</span> (sys_clk ),</span><br><span class="line"><span class="variable">.sys_rst_n</span> (sys_rst_n),</span><br><span class="line"><span class="variable">.led</span> (led )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Verilog/">Verilog</category>
      
      
      
      <comments>http://example.com/2021/11/07/Verilog/Testbench%E6%96%87%E4%BB%B6%E8%AF%BB%E6%B3%95%E5%92%8C%E5%86%99%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>第二章</title>
      <link>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</link>
      <guid>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</guid>
      <pubDate>Fri, 05 Nov 2021 13:35:49 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;语言成分&quot;&gt;&lt;a href=&quot;#语言成分&quot; class=&quot;headerlink&quot; title=&quot;语言成分&quot;&gt;&lt;/a&gt;语言成分&lt;/h1&gt;&lt;h2 id=&quot;关键字和标识符&quot;&gt;&lt;a href=&quot;#关键字和标识符&quot; class=&quot;headerlink&quot; title=&quot;关键字</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="语言成分"><a href="#语言成分" class="headerlink" title="语言成分"></a>语言成分</h1><h2 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h2><p><strong>关键字</strong>略。</p><p><strong>标识符命名规则</strong>：</p><ol><li>标识符必须以字母、下划线_ 、美元符$开头。</li><li>标识符其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合。</li><li>Java 标识符大小写敏感，且长度无限制。</li><li>不可以是Java的关键字。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">合法的标识符：</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> _123 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> $12aa = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> 变量<span class="number">1</span> = <span class="number">55</span>;</span><br><span class="line">不合法的标识符：</span><br><span class="line"><span class="keyword">int</span> 1a = <span class="number">3</span>; <span class="comment">//不能用数字开头</span></span><br><span class="line"><span class="keyword">int</span> a# = <span class="number">3</span>; <span class="comment">//不能包含#这样的特殊字符</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">int</span> = <span class="number">3</span>; <span class="comment">//不能使用关键字</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="\images\Java\第二章\1.jpg" style="zoom:67%;"></p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p><strong>数组(Array),类(class),接口(interface)。</strong></p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>,<span class="keyword">short</span>,<span class="keyword">char</span>—&gt; <span class="keyword">int</span> —&gt; <span class="keyword">long</span>—&gt; <span class="keyword">float</span> —&gt; <span class="keyword">double</span> </span><br><span class="line"><span class="comment">//容量从高到低。</span></span><br></pre></td></tr></table></figure><p><strong>转换规则：</strong></p><ul><li>不能对boolean类型进行类型转换。</li><li>不能把对象类型转换成不相关类的对象。</li><li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li><li>转换过程中可能导致溢出或损失精度，如<code>int i =128;   byte b = (byte)i;</code>，byte类型最大127，此时b为-128.</li><li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入</li></ul><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Java是一种强类型语言，每个变量都必须声明其类型。</p><p><strong>变量类型划分：</strong></p><ol><li><strong>局部</strong>变量：方法或语句块内部定义的变量。生命周期是 从声明位置开始到”}”为止。在使用前必须先声明和初始化（赋初值）</li><li><strong>实例</strong>变量：<strong>方法外部</strong>、<strong>类的内部</strong>定义的变 量。从属于对象，生命周期伴随对象始终。如果不自行初始化，他会自动初始化成该类型的默认初始值（数值型变量初始化成0或0.0，字符型变量的初 始化值是16位的0，布尔型默认是false）</li><li><strong>静态</strong>变量：使用static定义。 从属于类，生命周期伴随类始终，从类加载到卸载。如果不自行初始化，他会自动初始化成该类型的默认初始值（数值型变量初始化成0或0.0，字符型变量的初始化值是16位的0，布尔型默认是false）</li></ol><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>定义：<code>public static final double PI = 3.14;</code></p><p>其值无法改变，只能被初始化一次。常量的命名通常使用全大写，如果单词较多则使用下划线进行分隔。</p><h2 id="一些运算符"><a href="#一些运算符" class="headerlink" title="一些运算符"></a>一些运算符</h2><p><strong>&lt;&lt;：</strong>左移运算符（丢弃最高位，0补最低位）</p><p><strong>>&gt;：</strong>右移运算符（符号位不变，左边补上符号位）</p><p><strong>>&gt;&gt;：</strong>无符号移位运算符（无符号右移、忽略符号位扩展、0补最高位。无符号右移中的符号位也跟着变，<strong>无符号的意思是将符号位当作数字位看待</strong>。）</p><p>右移一位相当于除2取商。左移 一位相当于乘2。</p><h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><p>略</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组为引用数据类型。相当于有一个指针值着吧。</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p><strong>定义方法</strong>:<code>int x[] = new int[5];</code>或者<code>int x[]; x = new int[5];</code>或者<code>int x[] = &#123;1, 2, 3, 4, 5&#125;;</code></p><p><img src="\images\Java\第二章\2.jpg" style="zoom:67%;"></p><p><strong>for语句遍历：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (类型 变量 : 数组)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> value : fib)<span class="comment">//类似py迭代器</span></span><br><span class="line"><span class="comment">//vaue获得fib数组每个元素，</span></span><br><span class="line"><span class="comment">//相当于fib[i]</span></span><br><span class="line">System.out.print(<span class="string">&quot; &quot;</span>+value);</span><br></pre></td></tr></table></figure><p>关于<strong>引用数据类型</strong>这一说：</p><p><img src="\images\Java\第二章\3.jpg" style="zoom:50%;"></p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><strong>定义方法：</strong><code>int mat[][] = new int[3][4];或者int mat[][] = &#123; &#123;1,2,3&#125;,&#123;4,5,6&#125; &#125;</code></p><p><img src="\images\Java\第二章\4.jpg" style="zoom:50%;"></p><p><img src="\images\Java\第二章\5.jpg" style="zoom:50%;"></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本定义方法</span></span><br><span class="line">[修饰符…] 返回值类型 方法名([参数列表])</span><br><span class="line">&#123;</span><br><span class="line">语句序列;</span><br><span class="line">[<span class="keyword">return</span> [返回值]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><img src="\images\Java\第二章\6.jpg" style="zoom:50%;"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java/">Java</category>
      
      
      
      <comments>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%BA%8C%E7%AB%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>第一章</title>
      <link>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%B8%80%E7%AB%A0/</link>
      <guid>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%B8%80%E7%AB%A0/</guid>
      <pubDate>Fri, 05 Nov 2021 12:50:31 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;package关键字&quot;&gt;&lt;a href=&quot;#package关键字&quot; class=&quot;headerlink&quot; title=&quot;package关键字&quot;&gt;&lt;/a&gt;package关键字&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;包规则&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;packa</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="package关键字"><a href="#package关键字" class="headerlink" title="package关键字"></a>package关键字</h2><ul><li>包规则</li></ul><ol><li><p>package就是类的命名空间，用来唯一标识这个类，防止类的重名，比如你和我都有一个Hello类，将我们的代码合并，如果我们使用了package进行打包，我们的类属于不同的包，这时就避免了这种错误。实质就是将字节码文件（.class）分类存放。包其实就是文件夹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zhangsan;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> lisi;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一般情况，一个公司、组织、社团中所定义的包的名字，就是他们官网的域名（倒过来），因为域名一定是全球唯一的，不可能有俩个一样的域名。例如，<a href="http://commons.apache.org/">http://commons.apache.org/</a> 这官网下的代码中的包，都是 <code>package org.apache.commons;</code> 开头的。</p></li><li><p>类加上包名之后，编译的时候要带上包名，用<code>java com.briup.test.Hello</code>在命令行运行，</p></li></ol><ul><li>运行规则</li></ul><ol><li><p>如果运行的Hello类，没有指定包，Hello类一定对应的是Hello.class。那么当运行java Hello的时候，JVM会从CLASSPATH中指定的路径中查找，是否有Hello.class这个文件，如果有那么就加载到内存，然后运行，如果没有那么就报错</p></li><li><p>如果运行的Hello类，指定了包，例如是package com.briup.test; Hello类一定对应的是com/briup/test/Hello.class（固定要求）。那么当运行java com.briup.test.Hello的时候，JVM会从CLASSPATH中指定的路径中查找，是否有com/briup/test/Hello.class这个文件，如果有那么就加载到内存，然后运行，如果没有那么就报错。<br>注意，这个时候JVM从CLASSPATH的路径中，会先找com这个文件夹，然后依次找下去。因为如果有包存在的时候，这个包就是这个类不可分割的一部分。</p><p>这个情况下，CLASSPATH中就要配置com文件夹所在的路径。</p></li><li><p>如果运行的Hello类，被打包到一个jar中，比如是me.jar。</p><p>当运行java Hello的时候，JVM会从CLASSPATH中指定的路径中查找，是否有me.jar，如果有那么就从me.jar中将Hello.class载到内存，然后运行，如果没有那么就报错。（这是Hello没指定包的情况）<br>当运行java com.briup.test.Hello的时候，JVM会从CLASSPATH中指定的路径中查找，是否有me.jar，如果有那么就从me.jar中将com/briup/test/Hello.class加载到内存，然后运行，如果没有那么就报错。（这是Hello指定包的情况）</p></li></ol><ul><li>访问规则</li></ul><ol><li>如果类不是public的，则在不同包中的其它类无法访问它</li></ol><h2 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a>import关键字</h2><p>规则：</p><ol><li><p>使用<code>xxx.*</code>可以调用包下的所有结构，但是该包的子包的结构仍需import调用 例：<code>xxx.yyy.ABC</code></p></li><li><p>如果源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全名的方式显示。最好都加上包名进行区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx.yyy.aaa.ABC;</span><br><span class="line"></span><br><span class="line">ABC a=<span class="keyword">new</span> ABC();</span><br><span class="line"></span><br><span class="line">xxx.yyy.zzz.ABC a1=<span class="keyword">new</span> xxx.yyy.zzz.ABC();</span><br></pre></td></tr></table></figure></li><li><p>import static :导入指定类或接口中的静态结构：属性和方法。</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java/">Java</category>
      
      
      
      <comments>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%B8%80%E7%AB%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Basic</title>
      <link>http://example.com/2021/09/25/Verilog/Basics/</link>
      <guid>http://example.com/2021/09/25/Verilog/Basics/</guid>
      <pubDate>Sat, 25 Sep 2021 09:57:52 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Wire&quot;&gt;&lt;a href=&quot;#Wire&quot; class=&quot;headerlink&quot; title=&quot;Wire&quot;&gt;&lt;/a&gt;Wire&lt;/h2&gt;&lt;p&gt;wire是单向的。从source流向sinks(接收器)。连续赋值时(continuous assignment)(assi</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Wire"><a href="#Wire" class="headerlink" title="Wire"></a>Wire</h2><p>wire是单向的。从source流向sinks(接收器)。连续赋值时(continuous assignment)(assign left = right)，right被驱动给left。之所以叫他continuous是因为sinks一直随着souce改变。不是一次性赋值。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Verilog/">Verilog</category>
      
      
      
      <comments>http://example.com/2021/09/25/Verilog/Basics/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>索引</title>
      <link>http://example.com/2021/09/24/numpy/%E7%B4%A2%E5%BC%95/</link>
      <guid>http://example.com/2021/09/24/numpy/%E7%B4%A2%E5%BC%95/</guid>
      <pubDate>Fri, 24 Sep 2021 02:24:53 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">rand = np.random.RandomState(<span class="number">42</span>)</span><br><span class="line">x = rand.randint(<span class="number">100</span>, size=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">ind = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(x[ind])</span><br><span class="line">ind = np.array([[<span class="number">3</span>, <span class="number">7</span>],[<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="built_in">print</span>(x[ind])</span><br><span class="line">X = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">row = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">col = np.array([<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(X[row,col])<span class="comment">#一一对应</span></span><br><span class="line"><span class="comment">#在索引中，索引值的配对遵循广播的规则。因此当我们将一个</span></span><br><span class="line"><span class="comment">#列向量和一个行向量组合在一个索引中时，会得到一个二维的结果：</span></span><br><span class="line"><span class="comment">#print(row[:,np.newaxis]),维度变成3*1</span></span><br><span class="line"><span class="built_in">print</span>(X[row[:,np.newaxis], col])</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">[<span class="number">51</span> <span class="number">92</span> <span class="number">14</span> <span class="number">71</span> <span class="number">60</span> <span class="number">20</span> <span class="number">82</span> <span class="number">86</span> <span class="number">74</span> <span class="number">74</span>]</span><br><span class="line">[<span class="number">71</span> <span class="number">86</span> <span class="number">60</span>]</span><br><span class="line">[[<span class="number">71</span> <span class="number">86</span>]</span><br><span class="line"> [<span class="number">60</span> <span class="number">20</span>]]</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line">[ <span class="number">2</span>  <span class="number">5</span> <span class="number">11</span>]</span><br><span class="line">[[ <span class="number">2</span>  <span class="number">1</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">5</span>  <span class="number">7</span>]</span><br><span class="line"> [<span class="number">10</span>  <span class="number">9</span> <span class="number">11</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#组合索引</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"><span class="built_in">print</span>(X[<span class="number">2</span>, [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(X[<span class="number">1</span>:, [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line">[<span class="number">10</span>  <span class="number">8</span>  <span class="number">9</span>]</span><br><span class="line">[[ <span class="number">6</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [<span class="number">10</span>  <span class="number">8</span>  <span class="number">9</span>]]</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/numpy/">numpy</category>
      
      
      
      <comments>http://example.com/2021/09/24/numpy/%E7%B4%A2%E5%BC%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>http://example.com/2021/09/19/%E4%BF%A1%E5%8F%B7/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</link>
      <guid>http://example.com/2021/09/19/%E4%BF%A1%E5%8F%B7/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</guid>
      <pubDate>Sat, 18 Sep 2021 17:03:55 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;傅里叶变换 FT Fourier transform&lt;/p&gt;
&lt;p&gt;傅里叶级数 FS Fourier series&lt;/p&gt;
&lt;p&gt;离散傅里叶变换 DFT discrete fourier transform&lt;/p&gt;
&lt;p&gt;离散时间傅立叶变换 DTFT Discrete ti</description>
        
      
      
      
      <content:encoded><![CDATA[<p>傅里叶变换 FT Fourier transform</p><p>傅里叶级数 FS Fourier series</p><p>离散傅里叶变换 DFT discrete fourier transform</p><p>离散时间傅立叶变换 DTFT Discrete time Fourier Transform</p><p>加上I（inverse）就是逆变换</p><p>时域连续周期对应频域离散非周期</p><p>时域连续非周期对应频域连续非周期</p><p>时域离散周期对应频域离散周期</p><p>时域离散非周期对应频域连续周期</p><p>综上：</p><div class="table-container"><table><thead><tr><th>时域</th><th>频域</th></tr></thead><tbody><tr><td>连续</td><td>非周期</td></tr><tr><td>周期</td><td>离散</td></tr><tr><td>离散</td><td>周期</td></tr><tr><td>非周期</td><td>连续</td></tr></tbody></table></div>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2021/09/19/%E4%BF%A1%E5%8F%B7/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>频率</title>
      <link>http://example.com/2021/09/18/%E4%BF%A1%E5%8F%B7/%E9%A2%91%E7%8E%87/</link>
      <guid>http://example.com/2021/09/18/%E4%BF%A1%E5%8F%B7/%E9%A2%91%E7%8E%87/</guid>
      <pubDate>Sat, 18 Sep 2021 15:58:34 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;关于模拟频率，模拟角频率，数字角频率&quot;&gt;&lt;a href=&quot;#关于模拟频率，模拟角频率，数字角频率&quot; class=&quot;headerlink&quot; title=&quot;关于模拟频率，模拟角频率，数字角频率&quot;&gt;&lt;/a&gt;关于模拟频率，模拟角频率，数字角频率&lt;/h2&gt;&lt;script t</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="关于模拟频率，模拟角频率，数字角频率"><a href="#关于模拟频率，模拟角频率，数字角频率" class="headerlink" title="关于模拟频率，模拟角频率，数字角频率"></a>关于模拟频率，模拟角频率，数字角频率</h2><script type="math/tex; mode=display">f = \frac 1T = \frac {1\rm次} {\rm需要的时间(单位秒)}(Hz) \ \ \ \ \ \ \ \  \ \ \ \ \ \  \Omega = 2\pi f(rad/s)</script><p>$f$公式分式的上部是1次，下部是需要的时间，意思是变化1次需要的时间，所以$f$除下来就是1秒内变化的次数，而角频率$\Omega$则是将1次替换成了2$\pi$，意思就是一周需要多少时间，除下来就是一秒内走的弧度。</p><p>实际上在圆周运动或者交流电的变化中，这里的2$\pi$也就相当于一次变化。</p><p>在信号与系统中一般用$\omega$表示模拟角频率，而在数字信号处理中一般用$\Omega$表示模拟角频率，使用$\omega$表示数字角频率。</p><p>再来看一个例子：比如风扇1秒钟转10次，则其(模拟)频率$f$=10Hz，Hz=1/s；也即信号在一秒钟内重复的次数。便于理解，假设一个点在单位圆上运动，如图1所示，点在圆上一秒钟转10圈，则该点的运动频率为10Hz.</p><p><img src="/images/信号/频率/1.png" style="zoom:67%;"></p><p>而模拟角频率$\omega$，是以弧度来表示转的圈数，一圈是2$\pi$弧度，则该点的运动频率也可表示为2$\pi$10rad/s，由此可以看出，$\omega$ = 2<em>*$\pi$</em>*$f$。注意模拟角频率的单位是rad/s.</p><p>数字频率是对模拟频率的采样，数字频率代表的是两个采样点之间的间隔。还是以一点在圆上运动为例，1秒钟转动10圈，从该点运动开始，<strong>以1秒钟采样100次进行采样</strong>，可以得到，每次采样都可得到该点在圆上的位置，该点在圆上的位置如图2所示，采样点之间存在间隔，要以弧度$\omega$表示这种间隔，$\omega$ = 2$\pi$10/100(将1秒替换成100Hz，也就是100次),可得到$\omega$ = 0.2$\pi$ rad</p><p><img src="/images/信号/频率/2.png" style="zoom:67%;"></p><p>由此得到数字频率,$\omega$对应着采样的密集程度，所以叫做数字频率：</p><script type="math/tex; mode=display">\omega = \Omega * T_s =  \frac {\Omega} {f_s} = \frac {2\pi * \Omega} {\omega_s} = \frac {2\pi * f} {f_s}\ \ \ \ \ \  \rm数字角频率 = 模拟角频率 * 采样周期</script><p>由公式可以看出，数字频率是模拟频率对采样频率的归一化处理,只不过这里的一是一周（一圈）也就是$2\pi$。</p><p>有奈奎斯特采样定律得知$\omega_s ≥ 2\Omega$,因此$\omega ≤ \pi$。</p><p>模拟信号周期T的话意思就是进行一次需要多长时间，或者是进行一周($2\pi$)要多长时间.</p><p>数字信号周期N的话意思就是经过$2\pi$需要多少点</p><p>并且数字频率和数字周期满足下列关系：</p><script type="math/tex; mode=display">N = \frac {2\pi * k} {\omega}(k为正整数)</script><h2 id="另一种理解"><a href="#另一种理解" class="headerlink" title="另一种理解"></a>另一种理解</h2><p>加入我们从最简单的正弦函数$sin(\Omega t)$出发，每一个信号都可以由正弦余弦组成，那么只需要看正弦函数的数字转换规律，比如数字周期，数字频率等。</p><h2 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h2><p><img src="/images/信号/频率/3.jpg" style="zoom:40%;"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E4%BF%A1%E5%8F%B7/">信号</category>
      
      
      
      <comments>http://example.com/2021/09/18/%E4%BF%A1%E5%8F%B7/%E9%A2%91%E7%8E%87/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
