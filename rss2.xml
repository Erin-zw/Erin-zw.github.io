<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Erin枫</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>来者犹可追</description>
    <pubDate>Sun, 07 Nov 2021 12:47:06 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>parameter,defparame,`define,localparam四者区别</title>
      <link>http://example.com/2021/11/07/Verilog/parameter/</link>
      <guid>http://example.com/2021/11/07/Verilog/parameter/</guid>
      <pubDate>Sun, 07 Nov 2021 09:02:40 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;figure class=&quot;highlight verilog&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span>:    作用 -&gt; 常用于定义常量可以跨模块、跨文件;</span></span><br><span class="line">            范围 -&gt; 整个工程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span>:  作用 -&gt; 常用于模块间参数传递;</span><br><span class="line">            范围 -&gt; 本<span class="keyword">module</span>内有效的定义;</span><br><span class="line"></span><br><span class="line"><span class="keyword">localparam</span>: 作用 -&gt; 常用于状态机的参数定义;</span><br><span class="line">            范围 -&gt; 本<span class="keyword">module</span>内有效的定义，不可用于参数传递;</span><br><span class="line"><span class="keyword">localparam</span> cannot be used <span class="keyword">within</span> the <span class="keyword">module</span> port <span class="keyword">parameter</span> list.</span><br></pre></td></tr></table></figure><h2 id="Parameter"><a href="#Parameter" class="headerlink" title="Parameter"></a>Parameter</h2><p>可以放在模块头上也可以放在模块的内部，他可以通过defparameter的方式或者模块实例化的时候进行重写。</p><p><strong>Example：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo</span><br><span class="line">#(<span class="keyword">parameter</span> MSB=<span class="number">3</span>, LSB=<span class="number">0</span>, DEPTH=<span class="number">4</span>)<span class="comment">//可以被重写</span></span><br><span class="line"> (port_list );</span><br><span class="line"> item;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo</span><br><span class="line"> (port_list );</span><br><span class="line"> <span class="keyword">parameter</span> MSB=<span class="number">3</span>, LSB=<span class="number">0</span>, DEPTH=<span class="number">4</span><span class="comment">//可以被重写</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>一旦有模块参数被写在模块头部，则出现在模块内部的模块参数被视为本地参数，不能被重写。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo</span><br><span class="line"> #(<span class="keyword">parameter</span> MSB=<span class="number">3</span>, LSB=<span class="number">0</span>)<span class="comment">//可以被重写</span></span><br><span class="line"> (port_list );</span><br><span class="line"><span class="keyword">parameter</span> DEPTH=<span class="number">4</span>; <span class="comment">//不能被重写</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>在上层模块对参数重写的方式如下:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)F1<span class="variable">.MSB</span>=<span class="number">4</span>;F1<span class="variable">.LSB</span>=<span class="number">2</span>;fifo F1;</span><br><span class="line"><span class="number">2</span>) fifo <span class="variable">#(4,2) F1(port_list)</span>;</span><br><span class="line"><span class="number">3</span>) fifo <span class="variable">#(.LSB(2), .MSB(4)) fifo(port_list)</span>;</span><br></pre></td></tr></table></figure><h2 id="defparam修改参数"><a href="#defparam修改参数" class="headerlink" title="defparam修改参数"></a>defparam修改参数</h2><p>当一个模块引用另外一个模块时，高层模块可以改变低层模块用parameter定义的参数值。例子代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Top(...);<span class="comment">//这是一个顶层模块</span></span><br><span class="line">    <span class="keyword">defparam</span>    U_D1<span class="variable">.Width</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">defparam</span>    U_D1<span class="variable">.Polarity</span> = <span class="number">0</span>;<span class="comment">//使得U_D1的Width = 4， Polarity = 0；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defparam</span>    U_D2<span class="variable">.Width</span> = <span class="number">5</span>;<span class="comment">//使得U_D2的Width = 5，Polarity 不变，即为1；</span></span><br><span class="line">    Decode U_D1();</span><br><span class="line">    Decode U_D2(); </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Decode(A,F);    <span class="comment">//这是一个子模块</span></span><br><span class="line">    <span class="keyword">parameter</span> Width = <span class="number">1</span>, Polarity = <span class="number">1</span>;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>也可以模块实例化的时候进行修改，代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Top(...);<span class="comment">//这是一个顶层模块</span></span><br><span class="line">    Decode <span class="variable">#(4,0) U_D1()</span>; <span class="comment">//使得Width = 4， Polarity = 0；</span></span><br><span class="line">    Decode <span class="variable">#(5) U_D2()</span>; <span class="comment">//使得 Width = 5，Polarity 不变，即为1；</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Decode(A,F);    <span class="comment">//这是一个子模块</span></span><br><span class="line">    <span class="keyword">parameter</span> Width = <span class="number">1</span>, Polarity = <span class="number">1</span>;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="define"><a href="#define" class="headerlink" title="`define"></a>`define</h2><p><strong>概念：</strong>可以跨模块的定义，写在模块名称上面，在整个设计工程都有效。一旦define指令被编译，其在整个编译过程中都有效。例如，通<br>过另一个文件中的define指令，定义的常量可以被其他文件调用,直到遇到undef；</p><p><strong>举例：</strong>定义 define UART_CNT 10’d1024.使用UART_CNT</p><h2 id="localparam："><a href="#localparam：" class="headerlink" title="localparam："></a>localparam：</h2><p><strong>概念：</strong>本module内有效的定义，不可用于参数传递；localparamcannot be used within the module port parameter list.一般情况下，状态机的参数都是用localparam的。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Verilog/">Verilog</category>
      
      
      
      <comments>http://example.com/2021/11/07/Verilog/parameter/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>时域卷积频域相乘</title>
      <link>http://example.com/2021/11/07/%E4%BF%A1%E5%8F%B7/%E6%97%B6%E5%9F%9F%E5%8D%B7%E7%A7%AF%E9%A2%91%E5%9F%9F%E7%9B%B8%E4%B9%98/</link>
      <guid>http://example.com/2021/11/07/%E4%BF%A1%E5%8F%B7/%E6%97%B6%E5%9F%9F%E5%8D%B7%E7%A7%AF%E9%A2%91%E5%9F%9F%E7%9B%B8%E4%B9%98/</guid>
      <pubDate>Sun, 07 Nov 2021 07:33:57 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;为什么时域卷积频域就是相乘&quot;&gt;&lt;a href=&quot;#为什么时域卷积频域就是相乘&quot; class=&quot;headerlink&quot; title=&quot;为什么时域卷积频域就是相乘&quot;&gt;&lt;/a&gt;为什么时域卷积频域就是相乘&lt;/h2&gt;&lt;p&gt;​    一般教科书都是选择理论证明，但是如何直观去</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="为什么时域卷积频域就是相乘"><a href="#为什么时域卷积频域就是相乘" class="headerlink" title="为什么时域卷积频域就是相乘"></a>为什么时域卷积频域就是相乘</h2><p>​    一般教科书都是选择理论证明，但是如何直观去理解呢。我们知道一个信号可以傅里叶变换分解后然后变成很多个不同频率正弦信号。那个我们将两个信号去卷积，正弦信号卷积分配，不同频率的正弦信号卷积后为0（“正交”），那么就是相同频率的正弦信号相卷积，频率不变，辐值相乘。这在频域上就表现为相乘。</p><p>​    从知乎上看到的，写的很好，分享一下</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E4%BF%A1%E5%8F%B7/">信号</category>
      
      
      
      <comments>http://example.com/2021/11/07/%E4%BF%A1%E5%8F%B7/%E6%97%B6%E5%9F%9F%E5%8D%B7%E7%A7%AF%E9%A2%91%E5%9F%9F%E7%9B%B8%E4%B9%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Testbench文件编写方法</title>
      <link>http://example.com/2021/11/07/Verilog/Testbench%E6%96%87%E4%BB%B6%E8%AF%BB%E6%B3%95%E5%92%8C%E5%86%99%E6%B3%95/</link>
      <guid>http://example.com/2021/11/07/Verilog/Testbench%E6%96%87%E4%BB%B6%E8%AF%BB%E6%B3%95%E5%92%8C%E5%86%99%E6%B3%95/</guid>
      <pubDate>Sun, 07 Nov 2021 07:22:45 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;转载：&lt;a href=&quot;https://blog.csdn.net/weixin_46423500/article/details/113264878&quot;&gt;https://blog.csdn.net/weixin_46423500/article/details/113264</description>
        
      
      
      
      <content:encoded><![CDATA[<p>转载：<a href="https://blog.csdn.net/weixin_46423500/article/details/113264878">https://blog.csdn.net/weixin_46423500/article/details/113264878</a></p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>testbench文件基本结构：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 仿真单位/仿真精度</span></span><br><span class="line"><span class="keyword">module</span> test_bench();</span><br><span class="line"><span class="comment">//通常 testbench没有输入与输出端口</span></span><br><span class="line">信号或变量定义声明</span><br><span class="line">使用<span class="keyword">initial</span>或<span class="keyword">always</span>语句产生激励波形</span><br><span class="line">例化设计模块</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="声明仿真精度和仿真单位"><a href="#声明仿真精度和仿真单位" class="headerlink" title="声明仿真精度和仿真单位"></a>声明仿真精度和仿真单位</h3><p>/#(延时时间)，#(10ns)代表延时10ns</p><p>仿真精度就是说最低的延时精度，比如说<code>`timescale 1ns/1ns</code>，延时精度只能达到1ns</p><p>如果想要延时10.001ns，就要把仿真精度改成1ps(1ns = 1000ps)。</p><h3 id="定义模块名"><a href="#定义模块名" class="headerlink" title="定义模块名"></a>定义模块名</h3><p><code>module flow_led_tb();</code></p><p>模块名的命名方式一般在被测模块名后面加上“ _ tb”，或者在被测模块名前面加上“tb_”，表示为哪个模块提供激励测试文件，通常激励文件不需要定义输入和输出端口。</p><h3 id="信号或常量定义"><a href="#信号或常量定义" class="headerlink" title="信号或常量定义"></a>信号或常量定义</h3><p><strong>常量：</strong></p><p> 代码中定义的常量有时需要频繁的修改，为了方便修改，可以把常量定义成参数的形式，定义参数的关键字为parameter，代码如下：</p><p><code>parameter T = 20;</code></p><p><strong>变量：</strong></p><p>Verilog代码中，常用声明信号或变量的关键字为reg和wire，在initial语句或者always语句中使用的变量定义成reg类型，在assign语句或者用于连接被例化模块名的信号定义成wire类型，声明方法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reg define</span></span><br><span class="line"><span class="keyword">reg</span> sys_clk; <span class="comment">// 时钟信号</span></span><br><span class="line"><span class="keyword">reg</span> sys_rst_n; <span class="comment">// 复位信号</span></span><br><span class="line"><span class="comment">//wire define</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] led;</span><br></pre></td></tr></table></figure><p><strong>使用initial或always语句产生激励波形：</strong><br> 产生时钟激励。代码表示每10ns（假设仿真单位是1ns），sys_clk的电平状态翻转一次，由于一个完整的时钟周期包括一个高电平和一个低电平，因此sys_clk的时钟周期为20ns，占空比为50%。代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> #<span class="number">10</span> sys_clk = ~sys_clk;</span><br></pre></td></tr></table></figure><p>如果要生成其它占空比时钟的话，代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">#<span class="number">6</span> sys_clk = <span class="number">0</span>; #<span class="number">4</span> sys_clk = <span class="number">1</span>; <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在always语句中设置了sys_clk的时钟周期，并没有设置初始值，因此sys_clk需要在initial语句中进行初始化。代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"> sys_clk = <span class="number">1&#x27;b0</span>; <span class="comment">// 时钟初始值</span></span><br><span class="line">sys_rst_n = <span class="number">1&#x27;b0</span>; <span class="comment">// 复位初始值</span></span><br><span class="line"> #<span class="number">20</span> sys_rst_n = <span class="number">1&#x27;b1</span>; <span class="comment">// 在第21ns的时候复位信号信号拉高</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="例化设计模块"><a href="#例化设计模块" class="headerlink" title="例化设计模块"></a>例化设计模块</h3><p>例化的设计模块是指被测模块，例化被测模块的目的是把被测模块和激励模块实例化起来，并且把被测模块的端口与激励模块的端口进行相应的连接，使得激励可以输入到被测模块。如果被测模块是由多个模块组成的，激励模块中只需要例化多个模块的顶层模块，代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow_led u0_flow_led (</span><br><span class="line"> <span class="variable">.sys_clk</span> (sys_clk ),</span><br><span class="line"> <span class="variable">.sys_rst_n</span> (sys_rst_n),</span><br><span class="line"> <span class="variable">.led</span> (led )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="完整文件"><a href="#完整文件" class="headerlink" title="完整文件"></a>完整文件</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">`<span class="meta-keyword">timescale</span> 1ns/1ns // 定义仿真时间单位1ns和仿真时间精度为1ns</span></span><br><span class="line"> <span class="keyword">module</span> flow_led_tb(); <span class="comment">// 测试模块</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//parameter define</span></span><br><span class="line"><span class="keyword">parameter</span> T = <span class="number">20</span>; <span class="comment">// 时钟周期为20ns</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//reg define</span></span><br><span class="line"><span class="keyword">reg</span> sys_clk; <span class="comment">// 时钟信号</span></span><br><span class="line"> <span class="keyword">reg</span> sys_rst_n; <span class="comment">// 复位信号</span></span><br><span class="line"><span class="comment">//wire define</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] led;</span><br><span class="line"><span class="comment">//给输入信号初始值</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">sys_clk = <span class="number">1&#x27;b0</span>;</span><br><span class="line">sys_rst_n = <span class="number">1&#x27;b0</span>; <span class="comment">// 复位</span></span><br><span class="line"><span class="variable">#(T+1)</span> sys_rst_n = <span class="number">1&#x27;b1</span>; <span class="comment">// 在第21ns的时候复位信号信号拉高</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//50Mhz的时钟，周期则为1/50Mhz=20ns,所以每10ns，电平取反一次</span></span><br><span class="line"><span class="keyword">always</span> <span class="variable">#(T/2)</span> sys_clk = ~sys_clk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例化flow_led模块</span></span><br><span class="line">flow_led u0_flow_led (</span><br><span class="line"><span class="variable">.sys_clk</span> (sys_clk ),</span><br><span class="line"><span class="variable">.sys_rst_n</span> (sys_rst_n),</span><br><span class="line"><span class="variable">.led</span> (led )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Verilog/">Verilog</category>
      
      
      
      <comments>http://example.com/2021/11/07/Verilog/Testbench%E6%96%87%E4%BB%B6%E8%AF%BB%E6%B3%95%E5%92%8C%E5%86%99%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>第二章</title>
      <link>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</link>
      <guid>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</guid>
      <pubDate>Fri, 05 Nov 2021 13:35:49 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;语言成分&quot;&gt;&lt;a href=&quot;#语言成分&quot; class=&quot;headerlink&quot; title=&quot;语言成分&quot;&gt;&lt;/a&gt;语言成分&lt;/h1&gt;&lt;h2 id=&quot;关键字和标识符&quot;&gt;&lt;a href=&quot;#关键字和标识符&quot; class=&quot;headerlink&quot; title=&quot;关键字</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="语言成分"><a href="#语言成分" class="headerlink" title="语言成分"></a>语言成分</h1><h2 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h2><p><strong>关键字</strong>略。</p><p><strong>标识符命名规则</strong>：</p><ol><li>标识符必须以字母、下划线_ 、美元符$开头。</li><li>标识符其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合。</li><li>Java 标识符大小写敏感，且长度无限制。</li><li>不可以是Java的关键字。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">合法的标识符：</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> _123 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> $12aa = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> 变量<span class="number">1</span> = <span class="number">55</span>;</span><br><span class="line">不合法的标识符：</span><br><span class="line"><span class="keyword">int</span> 1a = <span class="number">3</span>; <span class="comment">//不能用数字开头</span></span><br><span class="line"><span class="keyword">int</span> a# = <span class="number">3</span>; <span class="comment">//不能包含#这样的特殊字符</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">int</span> = <span class="number">3</span>; <span class="comment">//不能使用关键字</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="\images\Java\第二章\1.jpg" style="zoom:67%;"></p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p><strong>数组(Array),类(class),接口(interface)。</strong></p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>,<span class="keyword">short</span>,<span class="keyword">char</span>—&gt; <span class="keyword">int</span> —&gt; <span class="keyword">long</span>—&gt; <span class="keyword">float</span> —&gt; <span class="keyword">double</span> </span><br><span class="line"><span class="comment">//容量从高到低。</span></span><br></pre></td></tr></table></figure><p><strong>转换规则：</strong></p><ul><li>不能对boolean类型进行类型转换。</li><li>不能把对象类型转换成不相关类的对象。</li><li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li><li>转换过程中可能导致溢出或损失精度，如<code>int i =128;   byte b = (byte)i;</code>，byte类型最大127，此时b为-128.</li><li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入</li></ul><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Java是一种强类型语言，每个变量都必须声明其类型。</p><p><strong>变量类型划分：</strong></p><ol><li><strong>局部</strong>变量：方法或语句块内部定义的变量。生命周期是 从声明位置开始到”}”为止。在使用前必须先声明和初始化（赋初值）</li><li><strong>实例</strong>变量：<strong>方法外部</strong>、<strong>类的内部</strong>定义的变 量。从属于对象，生命周期伴随对象始终。如果不自行初始化，他会自动初始化成该类型的默认初始值（数值型变量初始化成0或0.0，字符型变量的初 始化值是16位的0，布尔型默认是false）</li><li><strong>静态</strong>变量：使用static定义。 从属于类，生命周期伴随类始终，从类加载到卸载。如果不自行初始化，他会自动初始化成该类型的默认初始值（数值型变量初始化成0或0.0，字符型变量的初始化值是16位的0，布尔型默认是false）</li></ol><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>定义：<code>public static final double PI = 3.14;</code></p><p>其值无法改变，只能被初始化一次。常量的命名通常使用全大写，如果单词较多则使用下划线进行分隔。</p><h2 id="一些运算符"><a href="#一些运算符" class="headerlink" title="一些运算符"></a>一些运算符</h2><p><strong>&lt;&lt;：</strong>左移运算符（丢弃最高位，0补最低位）</p><p><strong>>&gt;：</strong>右移运算符（符号位不变，左边补上符号位）</p><p><strong>>&gt;&gt;：</strong>无符号移位运算符（无符号右移、忽略符号位扩展、0补最高位。无符号右移中的符号位也跟着变，<strong>无符号的意思是将符号位当作数字位看待</strong>。）</p><p>右移一位相当于除2取商。左移 一位相当于乘2。</p><h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><p>略</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组为引用数据类型。相当于有一个指针值着吧。</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p><strong>定义方法</strong>:<code>int x[] = new int[5];</code>或者<code>int x[]; x = new int[5];</code>或者<code>int x[] = &#123;1, 2, 3, 4, 5&#125;;</code></p><p><img src="\images\Java\第二章\2.jpg" style="zoom:67%;"></p><p><strong>for语句遍历：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (类型 变量 : 数组)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> value : fib)<span class="comment">//类似py迭代器</span></span><br><span class="line"><span class="comment">//vaue获得fib数组每个元素，</span></span><br><span class="line"><span class="comment">//相当于fib[i]</span></span><br><span class="line">System.out.print(<span class="string">&quot; &quot;</span>+value);</span><br></pre></td></tr></table></figure><p>关于<strong>引用数据类型</strong>这一说：</p><p><img src="\images\Java\第二章\3.jpg" style="zoom:50%;"></p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><strong>定义方法：</strong><code>int mat[][] = new int[3][4];或者int mat[][] = &#123; &#123;1,2,3&#125;,&#123;4,5,6&#125; &#125;</code></p><p><img src="\images\Java\第二章\4.jpg" style="zoom:50%;"></p><p><img src="\images\Java\第二章\5.jpg" style="zoom:50%;"></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本定义方法</span></span><br><span class="line">[修饰符…] 返回值类型 方法名([参数列表])</span><br><span class="line">&#123;</span><br><span class="line">语句序列;</span><br><span class="line">[<span class="keyword">return</span> [返回值]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><img src="\images\Java\第二章\6.jpg" style="zoom:50%;"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java/">Java</category>
      
      
      
      <comments>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%BA%8C%E7%AB%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>第一章</title>
      <link>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%B8%80%E7%AB%A0/</link>
      <guid>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%B8%80%E7%AB%A0/</guid>
      <pubDate>Fri, 05 Nov 2021 12:50:31 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;package关键字&quot;&gt;&lt;a href=&quot;#package关键字&quot; class=&quot;headerlink&quot; title=&quot;package关键字&quot;&gt;&lt;/a&gt;package关键字&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;包规则&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;packa</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="package关键字"><a href="#package关键字" class="headerlink" title="package关键字"></a>package关键字</h2><ul><li>包规则</li></ul><ol><li><p>package就是类的命名空间，用来唯一标识这个类，防止类的重名，比如你和我都有一个Hello类，将我们的代码合并，如果我们使用了package进行打包，我们的类属于不同的包，这时就避免了这种错误。实质就是将字节码文件（.class）分类存放。包其实就是文件夹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zhangsan;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> lisi;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一般情况，一个公司、组织、社团中所定义的包的名字，就是他们官网的域名（倒过来），因为域名一定是全球唯一的，不可能有俩个一样的域名。例如，<a href="http://commons.apache.org/">http://commons.apache.org/</a> 这官网下的代码中的包，都是 <code>package org.apache.commons;</code> 开头的。</p></li><li><p>类加上包名之后，编译的时候要带上包名，用<code>java com.briup.test.Hello</code>在命令行运行，</p></li></ol><ul><li>运行规则</li></ul><ol><li><p>如果运行的Hello类，没有指定包，Hello类一定对应的是Hello.class。那么当运行java Hello的时候，JVM会从CLASSPATH中指定的路径中查找，是否有Hello.class这个文件，如果有那么就加载到内存，然后运行，如果没有那么就报错</p></li><li><p>如果运行的Hello类，指定了包，例如是package com.briup.test; Hello类一定对应的是com/briup/test/Hello.class（固定要求）。那么当运行java com.briup.test.Hello的时候，JVM会从CLASSPATH中指定的路径中查找，是否有com/briup/test/Hello.class这个文件，如果有那么就加载到内存，然后运行，如果没有那么就报错。<br>注意，这个时候JVM从CLASSPATH的路径中，会先找com这个文件夹，然后依次找下去。因为如果有包存在的时候，这个包就是这个类不可分割的一部分。</p><p>这个情况下，CLASSPATH中就要配置com文件夹所在的路径。</p></li><li><p>如果运行的Hello类，被打包到一个jar中，比如是me.jar。</p><p>当运行java Hello的时候，JVM会从CLASSPATH中指定的路径中查找，是否有me.jar，如果有那么就从me.jar中将Hello.class载到内存，然后运行，如果没有那么就报错。（这是Hello没指定包的情况）<br>当运行java com.briup.test.Hello的时候，JVM会从CLASSPATH中指定的路径中查找，是否有me.jar，如果有那么就从me.jar中将com/briup/test/Hello.class加载到内存，然后运行，如果没有那么就报错。（这是Hello指定包的情况）</p></li></ol><ul><li>访问规则</li></ul><ol><li>如果类不是public的，则在不同包中的其它类无法访问它</li></ol><h2 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a>import关键字</h2><p>规则：</p><ol><li><p>使用<code>xxx.*</code>可以调用包下的所有结构，但是该包的子包的结构仍需import调用 例：<code>xxx.yyy.ABC</code></p></li><li><p>如果源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全名的方式显示。最好都加上包名进行区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx.yyy.aaa.ABC;</span><br><span class="line"></span><br><span class="line">ABC a=<span class="keyword">new</span> ABC();</span><br><span class="line"></span><br><span class="line">xxx.yyy.zzz.ABC a1=<span class="keyword">new</span> xxx.yyy.zzz.ABC();</span><br></pre></td></tr></table></figure></li><li><p>import static :导入指定类或接口中的静态结构：属性和方法。</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java/">Java</category>
      
      
      
      <comments>http://example.com/2021/11/05/Java/%E7%AC%AC%E4%B8%80%E7%AB%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Basic</title>
      <link>http://example.com/2021/09/25/Verilog/Basics/</link>
      <guid>http://example.com/2021/09/25/Verilog/Basics/</guid>
      <pubDate>Sat, 25 Sep 2021 09:57:52 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Wire&quot;&gt;&lt;a href=&quot;#Wire&quot; class=&quot;headerlink&quot; title=&quot;Wire&quot;&gt;&lt;/a&gt;Wire&lt;/h2&gt;&lt;p&gt;wire是单向的。从source流向sinks(接收器)。连续赋值时(continuous assignment)(assi</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Wire"><a href="#Wire" class="headerlink" title="Wire"></a>Wire</h2><p>wire是单向的。从source流向sinks(接收器)。连续赋值时(continuous assignment)(assign left = right)，right被驱动给left。之所以叫他continuous是因为sinks一直随着souce改变。不是一次性赋值。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Verilog/">Verilog</category>
      
      
      
      <comments>http://example.com/2021/09/25/Verilog/Basics/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>索引</title>
      <link>http://example.com/2021/09/24/numpy/%E7%B4%A2%E5%BC%95/</link>
      <guid>http://example.com/2021/09/24/numpy/%E7%B4%A2%E5%BC%95/</guid>
      <pubDate>Fri, 24 Sep 2021 02:24:53 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">rand = np.random.RandomState(<span class="number">42</span>)</span><br><span class="line">x = rand.randint(<span class="number">100</span>, size=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">ind = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(x[ind])</span><br><span class="line">ind = np.array([[<span class="number">3</span>, <span class="number">7</span>],[<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="built_in">print</span>(x[ind])</span><br><span class="line">X = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">row = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">col = np.array([<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(X[row,col])<span class="comment">#一一对应</span></span><br><span class="line"><span class="comment">#在索引中，索引值的配对遵循广播的规则。因此当我们将一个</span></span><br><span class="line"><span class="comment">#列向量和一个行向量组合在一个索引中时，会得到一个二维的结果：</span></span><br><span class="line"><span class="comment">#print(row[:,np.newaxis]),维度变成3*1</span></span><br><span class="line"><span class="built_in">print</span>(X[row[:,np.newaxis], col])</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">[<span class="number">51</span> <span class="number">92</span> <span class="number">14</span> <span class="number">71</span> <span class="number">60</span> <span class="number">20</span> <span class="number">82</span> <span class="number">86</span> <span class="number">74</span> <span class="number">74</span>]</span><br><span class="line">[<span class="number">71</span> <span class="number">86</span> <span class="number">60</span>]</span><br><span class="line">[[<span class="number">71</span> <span class="number">86</span>]</span><br><span class="line"> [<span class="number">60</span> <span class="number">20</span>]]</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line">[ <span class="number">2</span>  <span class="number">5</span> <span class="number">11</span>]</span><br><span class="line">[[ <span class="number">2</span>  <span class="number">1</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">5</span>  <span class="number">7</span>]</span><br><span class="line"> [<span class="number">10</span>  <span class="number">9</span> <span class="number">11</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#组合索引</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"><span class="built_in">print</span>(X[<span class="number">2</span>, [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(X[<span class="number">1</span>:, [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line">[<span class="number">10</span>  <span class="number">8</span>  <span class="number">9</span>]</span><br><span class="line">[[ <span class="number">6</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [<span class="number">10</span>  <span class="number">8</span>  <span class="number">9</span>]]</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/numpy/">numpy</category>
      
      
      
      <comments>http://example.com/2021/09/24/numpy/%E7%B4%A2%E5%BC%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>http://example.com/2021/09/19/%E4%BF%A1%E5%8F%B7/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</link>
      <guid>http://example.com/2021/09/19/%E4%BF%A1%E5%8F%B7/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</guid>
      <pubDate>Sat, 18 Sep 2021 17:03:55 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;傅里叶变换 FT Fourier transform&lt;/p&gt;
&lt;p&gt;傅里叶级数 FS Fourier series&lt;/p&gt;
&lt;p&gt;离散傅里叶变换 DFT discrete fourier transform&lt;/p&gt;
&lt;p&gt;离散时间傅立叶变换 DTFT Discrete ti</description>
        
      
      
      
      <content:encoded><![CDATA[<p>傅里叶变换 FT Fourier transform</p><p>傅里叶级数 FS Fourier series</p><p>离散傅里叶变换 DFT discrete fourier transform</p><p>离散时间傅立叶变换 DTFT Discrete time Fourier Transform</p><p>加上I（inverse）就是逆变换</p><p>时域连续周期对应频域离散非周期</p><p>时域连续非周期对应频域连续非周期</p><p>时域离散周期对应频域离散周期</p><p>时域离散非周期对应频域连续周期</p><p>综上：</p><div class="table-container"><table><thead><tr><th>时域</th><th>频域</th></tr></thead><tbody><tr><td>连续</td><td>非周期</td></tr><tr><td>周期</td><td>离散</td></tr><tr><td>离散</td><td>周期</td></tr><tr><td>非周期</td><td>连续</td></tr></tbody></table></div>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2021/09/19/%E4%BF%A1%E5%8F%B7/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>频率</title>
      <link>http://example.com/2021/09/18/%E4%BF%A1%E5%8F%B7/%E9%A2%91%E7%8E%87/</link>
      <guid>http://example.com/2021/09/18/%E4%BF%A1%E5%8F%B7/%E9%A2%91%E7%8E%87/</guid>
      <pubDate>Sat, 18 Sep 2021 15:58:34 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;关于模拟频率，模拟角频率，数字角频率&quot;&gt;&lt;a href=&quot;#关于模拟频率，模拟角频率，数字角频率&quot; class=&quot;headerlink&quot; title=&quot;关于模拟频率，模拟角频率，数字角频率&quot;&gt;&lt;/a&gt;关于模拟频率，模拟角频率，数字角频率&lt;/h2&gt;&lt;script t</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="关于模拟频率，模拟角频率，数字角频率"><a href="#关于模拟频率，模拟角频率，数字角频率" class="headerlink" title="关于模拟频率，模拟角频率，数字角频率"></a>关于模拟频率，模拟角频率，数字角频率</h2><script type="math/tex; mode=display">f = \frac 1T = \frac {1\rm次} {\rm需要的时间(单位秒)}(Hz) \ \ \ \ \ \ \ \  \ \ \ \ \ \  \Omega = 2\pi f(rad/s)</script><p>$f$公式分式的上部是1次，下部是需要的时间，意思是变化1次需要的时间，所以$f$除下来就是1秒内变化的次数，而角频率$\Omega$则是将1次替换成了2$\pi$，意思就是一周需要多少时间，除下来就是一秒内走的弧度。</p><p>实际上在圆周运动或者交流电的变化中，这里的2$\pi$也就相当于一次变化。</p><p>在信号与系统中一般用$\omega$表示模拟角频率，而在数字信号处理中一般用$\Omega$表示模拟角频率，使用$\omega$表示数字角频率。</p><p>再来看一个例子：比如风扇1秒钟转10次，则其(模拟)频率$f$=10Hz，Hz=1/s；也即信号在一秒钟内重复的次数。便于理解，假设一个点在单位圆上运动，如图1所示，点在圆上一秒钟转10圈，则该点的运动频率为10Hz.</p><p><img src="/images/信号/频率/1.png" style="zoom:67%;"></p><p>而模拟角频率$\omega$，是以弧度来表示转的圈数，一圈是2$\pi$弧度，则该点的运动频率也可表示为2$\pi$10rad/s，由此可以看出，$\omega$ = 2<em>*$\pi$</em>*$f$。注意模拟角频率的单位是rad/s.</p><p>数字频率是对模拟频率的采样，数字频率代表的是两个采样点之间的间隔。还是以一点在圆上运动为例，1秒钟转动10圈，从该点运动开始，<strong>以1秒钟采样100次进行采样</strong>，可以得到，每次采样都可得到该点在圆上的位置，该点在圆上的位置如图2所示，采样点之间存在间隔，要以弧度$\omega$表示这种间隔，$\omega$ = 2$\pi$10/100(将1秒替换成100Hz，也就是100次),可得到$\omega$ = 0.2$\pi$ rad</p><p><img src="/images/信号/频率/2.png" style="zoom:67%;"></p><p>由此得到数字频率,$\omega$对应着采样的密集程度，所以叫做数字频率：</p><script type="math/tex; mode=display">\omega = \Omega * T_s =  \frac {\Omega} {f_s} = \frac {2\pi * \Omega} {\omega_s} = \frac {2\pi * f} {f_s}\ \ \ \ \ \  \rm数字角频率 = 模拟角频率 * 采样周期</script><p>由公式可以看出，数字频率是模拟频率对采样频率的归一化处理,只不过这里的一是一周（一圈）也就是$2\pi$。</p><p>有奈奎斯特采样定律得知$\omega_s ≥ 2\Omega$,因此$\omega ≤ \pi$。</p><p>模拟信号周期T的话意思就是进行一次需要多长时间，或者是进行一周($2\pi$)要多长时间.</p><p>数字信号周期N的话意思就是经过$2\pi$需要多少点</p><p>并且数字频率和数字周期满足下列关系：</p><script type="math/tex; mode=display">N = \frac {2\pi * k} {\omega}(k为正整数)</script><h2 id="另一种理解"><a href="#另一种理解" class="headerlink" title="另一种理解"></a>另一种理解</h2><p>加入我们从最简单的正弦函数$sin(\Omega t)$出发，每一个信号都可以由正弦余弦组成，那么只需要看正弦函数的数字转换规律，比如数字周期，数字频率等。</p><h2 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h2><p><img src="/images/信号/频率/3.jpg" style="zoom:40%;"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E4%BF%A1%E5%8F%B7/">信号</category>
      
      
      
      <comments>http://example.com/2021/09/18/%E4%BF%A1%E5%8F%B7/%E9%A2%91%E7%8E%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>比较和布尔逻辑</title>
      <link>http://example.com/2021/09/18/numpy/%E6%AF%94%E8%BE%83%EF%BC%8C%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91/</link>
      <guid>http://example.com/2021/09/18/numpy/%E6%AF%94%E8%BE%83%EF%BC%8C%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91/</guid>
      <pubDate>Sat, 18 Sep 2021 12:15:12 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;比较函数&quot;&gt;&lt;a href=&quot;#比较函数&quot; class=&quot;headerlink&quot; title=&quot;比较函数&quot;&gt;&lt;/a&gt;比较函数&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(x&gt;<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>( (<span class="number">2</span> * x) == (x ** <span class="number">2</span>))</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">[<span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>  <span class="literal">True</span>  <span class="literal">True</span>]</span><br><span class="line">[<span class="literal">False</span>  <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span> <span class="literal">False</span>]</span><br></pre></td></tr></table></figure><p>和算术运算符一样，比较运算操作在 NumPy 中也是借助通用函数来实 现的。例如当你写 x &lt; 3 时，NumPy 内部会使用 np.less(x, 3)</p><h2 id="操作布尔数组"><a href="#操作布尔数组" class="headerlink" title="操作布尔数组"></a>操作布尔数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">rng = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line">x = rng.randint(<span class="number">10</span>, size=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(np.count_nonzero(x &lt; <span class="number">6</span>))<span class="comment">#有多少值小于6</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x &lt; <span class="number">6</span>, axis=<span class="number">1</span>))<span class="comment">#每行有多少个值小于6，小于6的值为1</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">any</span>(x &gt; <span class="number">8</span>))<span class="comment">#有没有值大于8</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">all</span>(x == <span class="number">6</span>))<span class="comment">#是否所有值都等于6</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">all</span>(x &lt; <span class="number">8</span>, axis=<span class="number">1</span>))<span class="comment">#是否每一行的所有值都小于8</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">[[<span class="number">5</span> <span class="number">0</span> <span class="number">3</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">9</span> <span class="number">3</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span>]]</span><br><span class="line"><span class="number">8</span></span><br><span class="line">[<span class="number">4</span> <span class="number">2</span> <span class="number">2</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">[ <span class="literal">True</span> <span class="literal">False</span>  <span class="literal">True</span>]</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/numpy/">numpy</category>
      
      
      
      <comments>http://example.com/2021/09/18/numpy/%E6%AF%94%E8%BE%83%EF%BC%8C%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
