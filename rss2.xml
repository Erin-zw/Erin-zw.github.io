<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Erin枫</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>来者犹可追</description>
    <pubDate>Sat, 20 Aug 2022 11:36:12 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>强化专题一（信号计算）</title>
      <link>http://example.com/2022/08/20/%E4%BF%A1%E5%8F%B7/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/</link>
      <guid>http://example.com/2022/08/20/%E4%BF%A1%E5%8F%B7/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/</guid>
      <pubDate>Sat, 20 Aug 2022 11:35:05 GMT</pubDate>
      
      
      
      
      <category domain="http://example.com/categories/%E4%BF%A1%E5%8F%B7/">信号</category>
      
      
      
      <comments>http://example.com/2022/08/20/%E4%BF%A1%E5%8F%B7/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>一段经历/2022.8.20</title>
      <link>http://example.com/2022/08/20/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%97%A0%E9%A2%98/</link>
      <guid>http://example.com/2022/08/20/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%97%A0%E9%A2%98/</guid>
      <pubDate>Fri, 19 Aug 2022 16:43:38 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;瞎扯&quot;&gt;&lt;a href=&quot;#瞎扯&quot; class=&quot;headerlink&quot; title=&quot;瞎扯&quot;&gt;&lt;/a&gt;瞎扯&lt;/h3&gt;&lt;p&gt;​        有时候真的是，人的想法和成长就在一念之间吧。&lt;/p&gt;
&lt;p&gt;​        之所以想写这篇博客大概也是觉得自己在8.19</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="瞎扯"><a href="#瞎扯" class="headerlink" title="瞎扯"></a>瞎扯</h3><p>​        有时候真的是，人的想法和成长就在一念之间吧。</p><p>​        之所以想写这篇博客大概也是觉得自己在8.19号晚上看专业课时（没有太大影响（滑稽））想通了吧。虽然从前几天起就一直想纪念一下到目前人生为止，最有意义的一段经历了，但是一直没想好或者说想明白我究竟明白了什么，得到了什么。既然我觉得我想明白了，那就记录一下这段经历吧。</p><p>​        想了几个主题，喜欢，友情，自我。从所谓喜欢到自我结束吧。</p><h3 id="喜欢"><a href="#喜欢" class="headerlink" title="喜欢"></a>喜欢</h3><p>​        这个也是一开始最困扰我的事吧。先说说我的结论吧，至少在一段时间之内，我可能会收起我的感情和欲望。我需要更多的时间提升自己，去生活，做自己想做的事。毕竟自己确实不优秀，也没资本。</p><p>​        这段时间我到底经历了什么，其实也比较简单也比较复杂，就“大概”阐述一下吧。</p><p>​        6.22号我选择了在考研压力之余去放松一下（仅此而已，别想多），参加学校组织的毕业典礼志愿者活动。22日中午吃饭就注意到了这个妹子（小g）。22号晚上结束，我就和同行的室友说感觉这个妹子真的对眼，我有点想要联系方式。我当时也在寝室说了一下想去要，调侃了一下手动增加考研难度，但是室友估计也没当回事，毕竟老口嗨怪了。晚上躺在床上我就在想，我单身这么多年了，好不容易看到一个对眼的，也该做点什么，不能怂（虽然现在想想确实也幼稚）。所以我在内心还是在给自己加油鼓劲的，希望第二天可以主动出击。</p><p>​        23号活动只有半天，到中午结束了，小g还没走在收拾东西。当时我其实还是纠结了很一会的，毕竟也“不甘心”就这么错过了。然后当时朋友也在催我搞快点，最后我还是下了决心去做了（这也算是我的一种成长）。没办法，当时抓住空挡，伺机就跑过去要了联系方式，我记得当时是加的qq，她扫的我的二维码。成功之后还是激动了好一会的。因为当时小g还在帮忙志愿活动收拾东西，所以就在下午两点说了第一句话，聊了一会。聊的时候其实也挺尴尬，我确实不大会。在简单的聊完之后，更多的当时我记得是一种压力（毕竟确实感觉聊得挺尴尬的以及怎么发展下去）。</p><p>​        就这样尬聊到27号，每天都是我主动找她，时间也比较固定，一般都是在晚上10.00左右。27号我主动提出使用微信更多一点，就加个微信，小g也同意了。然后开始转战微信。。</p><p>​        尬聊到7.3号，晚上问小g，小g说她爷爷走了，一时间也懵了，毕竟安慰人真的很难，不过最后也算是，不是很尴尬的安慰了吧。（此处没有表情我很难受）</p><p>​        转战微信后，大概要么就隔一天晚上找一次，要么就连续的。总之就还是比较累的，因为我一直在想该怎么去尬聊，怎么去吸引女生跟我去聊天，怎么去找话题，中间也看了不少知乎经验贴（迷信）。</p><p>​        一直到7.10号，她第一次主动找我，拍了一张常州站的照片过来，说她刚好经过，去上海找她同学，我还觉得算是一个进展（内心窃喜）。。</p><p>​        中间为了能和她有更多交集，我就提出了一起用番茄，不过用了一段时间也不了了之。人家可能确实出于礼貌跟我用了一段时间。。        前面这些天，我也是一直和朋友去吐槽我的一些看法和感受，总而言之精神内耗非常大，她的一些微不足道的举动也确实会影响到我的感受。朋友呢其实也一直在劝我打消念头，但是当时我确实还一直抱有幻想只能说。</p><p>​        7.28号，一个多月了，真的很累了对于我个人而言，所以晚上我选择了自爆，进行了各种旁敲侧击，她没有拒绝我，也没有表达什么感觉其他之类的话。我并不知道她的真实想法。但是呢，自爆后心里确实畅快了一些，后面的那些天我还是很累，所以有时候可能隔两三天找一次，她也主动找过我一两次，搞不懂她在想什么，也不知道我在想什么。</p><p>​        就这样继续尬聊，一直到8.14号。刚好那天我在武汉做过的那个家教家长，又找我让我帮忙去介绍一个同学给她继续当家教。然后晚上找她的聊天的时候，其实我能感觉到她其实对我的话题并不是很感兴趣。后来说到家教这个事，我就想问问她有没有兴趣，她似乎就来了兴趣，我发表了我对于家教的一些看法，她也并没有回应，而是一直在问我家教相关事宜。那个时候是真的有一种彻底灰心的感觉吧，有一种被当工具人的感觉（hhh）。然后当天晚上也找朋友聊了不少，虽然更多的也是我自己的自我安慰罢了。</p><p>​        一直到现在也没再找了，更多的是一种释怀了（这也是多亏了朋友的一些引导）。</p><p>​        这期间一些细节我也淡忘了，想不起来那就不想了。。。</p><p>​        总结一下，从一开始就是我自己的执念。首先我并没有理由去埋怨她，毕竟这是我的一厢情愿。在一个错误的时间，错误的地点做出了错误的举动。人家中间也提过，目前是把我当网友，我可能也只是那段时间刚好发癫，遇到对眼的人，就想去和她发展，但其实我可能并不喜欢她。其次我不够优秀，也不会聊天，并没有吸引到她。后来也在反思，她真的算是一个特别优秀的女生吗，从一开始的答案肯定慢慢到否定。从开始到熟悉，她给我的感觉从有好感到感觉到她兴趣匮乏逐渐失去好感。她不像小c现实生活很丰富懂得很多，愿意去聊一些别的东西。也不像小z那么会聊会找话题。给人的感觉就是稍微比较无聊的那种。那我为什么会想一直去坚持，因为她给我的感觉很真诚，至少在回复我的一些话时还算比较热情，所以我在自我麻醉对她还是有感觉的。当时我觉得这就够了，能不能聊到一起远没有她给我的感觉重要。但在自爆的那天开始以后，我觉得支撑我去找她的完完全全就是我的执念了，在那个时候可能所谓的好感已经消磨殆尽，毕竟现实里也只见过那两天。我也是人，输入没有反馈，我的热情也在消失。但是我又不想放弃，对所谓执念的一种不甘心可以说是吧。就这样一直在给自己增压。小丑独幕剧谢下帷幕，该清醒认清现实了。她也确实是过客，希望专注自己，不再摆烂了（），未来会有更好的事情发生。</p><h3 id="友情"><a href="#友情" class="headerlink" title="友情"></a>友情</h3><p>​        说真的，在这个暑假里除去我的这个所谓的小丑！独幕剧。给我带来最大意义的就是新朋友和老朋友了。很多想法都是在他们的引导下去产生和改变了的，非常感激。</p><p>​        老朋友自然不必多说，在身边和不在身边的，在情感上不管是打击也好，鼓励也罢，都是很感激他们的建议和倾听的。我有时候也在想，没有他们我那些事谁愿意听，又去分享给谁。我自己一个人去消化可能真的比较难顶。所以真的很感动，身边有几个愿意听我倾诉的老东西。</p><p>​        至于说到新朋友，也是很感动的。我记得最一开始是小z问我能不能分清绿茶，当时一时间真的很诧异（hhh），为什么刚加好友就问这么奇怪犀利的问题，不过我也算是大概回答了一下，因为一开始对小z印象就是很会聊天的女生，所以聊的时候没有太大压力其实。当时觉得能有个异性朋友很不错。后来呢逐渐熟悉了小c。也聊过一些东西。对于小c，我一开始不认识的时候印象就很好，确实长在了点上（hh）。后来认识了以后给我的感觉就是也是一个很真诚，很有个性的女生，知道自己想要什么，不想要什么。是一个能跟你聊一些有见解有内涵的事情的女生。包括在感情上也是给了我很多启发。那以前我并不觉得会有女生觉得我还ok（尴尬），也是挺感谢她们的吧（。她们两个人呢，确实是在很多事情上有自己独到的见解，包括也让我自信一点，以及情感上的指导等等。总之，非常感激两位朋友（不知所言）。</p><p>​        自习室的其他朋友也带给了我不一样的感受。zjy在国外留学，流露出的姿态和成熟度很值得学习，在谈吐上也学到很多，这也会比较激励我。感受到了小石这种会打游戏会通宵倒时差的女生带来的不一样的感觉（滑稽）。也体验到了未来的无名中医专家对中医方面的一些见解（大开眼界）。当然了，也还有比较多的事值得纪念，等我记起来再说！！。</p><p>​        总的来讲呢，更加见识到了现实的参差（可以讨论的点很多），也坚定了我转战现实专注自己的想法。</p><h3 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h3><p>​        想了想啊，确实是不该做出这种行为，但是做都做了，说这个好像也没用（废话）。。。。。。。。。。</p><p>​        目前也只能用提升自己骗骗自己先了（（（。</p><p>​        以前的我沉浸在自以为是的网络世界，但是呢，也算是体验过网络世界的深浅了，不亏。这段时间的经历让我认识到现实世界应该由我主动探索，去记录更多现实的美好，而不是继续沉浸在自以为是的虚拟世界了。很多事我可能只是不敢去做，但是现在我觉得一些害怕也在逐渐消失，更多的是一种期待吧。反正别摆烂了，也别那么不自信了！</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>​        首先感谢，居然能看到最后（自己看着都尬），佩服佩服！</p><p>​        反正瞎扯也扯这么多了（），有些地方，太正经，我受不了了。写了这么多，希望一些想法都能做到吧。</p><p>​        人生值得记录的事很多，以后我可能也会在个人主页更新一些别的想法和经历（希望我别摆烂），有兴趣欢迎来看。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%9D%82%E6%83%B3/">杂想</category>
      
      
      
      <comments>http://example.com/2022/08/20/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%97%A0%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>10M信号发生器</title>
      <link>http://example.com/2021/12/13/FPGA/10M%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/</link>
      <guid>http://example.com/2021/12/13/FPGA/10M%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/</guid>
      <pubDate>Mon, 13 Dec 2021 15:03:04 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;DDS简介&lt;/p&gt;
&lt;p&gt;DDS信号发生器采用&lt;strong&gt;直接数字频率合成&lt;/strong&gt;(Direct Digital Synthesis，简称DDS)技术，把信号发生器的频率稳定度、准确度提高到与基准频率相同的水平，并且可以在很宽的频率范围内进行精细的频率调节。采</description>
        
      
      
      
      <content:encoded><![CDATA[<p>DDS简介</p><p>DDS信号发生器采用<strong>直接数字频率合成</strong>(Direct Digital Synthesis，简称DDS)技术，把信号发生器的频率稳定度、准确度提高到与基准频率相同的水平，并且可以在很宽的频率范围内进行精细的频率调节。采用这种方法设计的信号源可工作于调制状态，可对输出电平进行调节，也可输出各种波形。</p><p>DDS原理</p><p><img src="\images\FPGA\DDS\2.png" style="zoom:50%;"></p><p>在参考频率时钟的驱动下，DDS模块开始工作；当每来一个参考时钟时，累加器就把频率控制字M与N位相位寄存器输出的值进行累加，将相加后的结果再输入到相位寄存器中，而相位寄存器就将在上一个参考时钟作用时产生的数据通过反馈的方式输送到N位累加器中。这样，在时钟的作用下，就可以不停的对频率控制字进行累加。此时，用相位累加器输出的数据就是信号的相位，这个数据作为地址在波形存储器中通过查找地址所对应的幅值表，就可以完成其从相位到幅值之间的转化。</p><p>在DDS模块中，输出频率的公式为：</p><p>根据DDS的相位寄存器的位数N，把360°平均分成2的N次方份。系统时钟代表一秒多少个频率控制字，M占据2的N次方的多少，这样算出来就是一秒多少个2的N次方。也就是多少个周期，也就是频率。</p><script type="math/tex; mode=display">f_{out} = \frac {f_c*M} {2^N} \\(f_{out}为输出信号频率，f_c为系统时钟频率，M为频率控制字，N为相位寄存器位数)\\ \Delta f = \frac {f_c} {2^N}\\(\Delta f为频率分辨率)</script><p>所谓相位控制字，可以理解为就是信号的初相。相位控制字计算公式：</p><script type="math/tex; mode=display">P_{off} = \frac {phase*(2^{N}-1)} {360°}\\(关于这里为什么要减一，是因为寄存器的范围是从0-(2^N-1)，也可以不减。只需要看P_{off}是不是直接输出值)</script><p><strong>注意点：</strong>为了使</p><p>10M信号发生器相关计算</p><p>已知系统时钟为50M，</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/FPGA/">FPGA</category>
      
      
      
      <comments>http://example.com/2021/12/13/FPGA/10M%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>测试</title>
      <link>http://example.com/2021/11/24/Matlab/Test/</link>
      <guid>http://example.com/2021/11/24/Matlab/Test/</guid>
      <pubDate>Wed, 24 Nov 2021 14:58:06 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;复数矩阵的转置、共轭、共轭转置&quot;&gt;&lt;a href=&quot;#复数矩阵的转置、共轭、共轭转置&quot; class=&quot;headerlink&quot; title=&quot;复数矩阵的转置、共轭、共轭转置&quot;&gt;&lt;/a&gt;复数矩阵的转置、共轭、共轭转置&lt;/h4&gt;&lt;p&gt;conj是共轭运算&lt;/p&gt;
&lt;scr</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="复数矩阵的转置、共轭、共轭转置"><a href="#复数矩阵的转置、共轭、共轭转置" class="headerlink" title="复数矩阵的转置、共轭、共轭转置"></a>复数矩阵的转置、共轭、共轭转置</h4><p>conj是共轭运算</p><script type="math/tex; mode=display">A = \begin{bmatrix}2+3i & 3-4i \\ 5+i & 7-2i \end{bmatrix}\ \\conj(A) = \begin{bmatrix}2-3i & 3+4i \\ 5-i & 7+2i\end{bmatrix}\ \\A.' = \begin{bmatrix}2+3i & 5+i \\ 3-4i & 7-2i \end{bmatrix}\ \\conj(A.') = A' = \begin{bmatrix}2-3i & 5-i \\ 3+4i & 7+2i \end{bmatrix}</script>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Matlab/">Matlab</category>
      
      
      
      <comments>http://example.com/2021/11/24/Matlab/Test/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>异常</title>
      <link>http://example.com/2021/11/12/Java/%E7%AC%AC%E4%BA%94%E7%AB%A0/</link>
      <guid>http://example.com/2021/11/12/Java/%E7%AC%AC%E4%BA%94%E7%AB%A0/</guid>
      <pubDate>Fri, 12 Nov 2021 13:13:33 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;异常处理基础&quot;&gt;&lt;a href=&quot;#异常处理基础&quot; class=&quot;headerlink&quot; title=&quot;异常处理基础&quot;&gt;&lt;/a&gt;异常处理基础&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;\images\Java\第五章\2.jpg&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="异常处理基础"><a href="#异常处理基础" class="headerlink" title="异常处理基础"></a>异常处理基础</h1><p><img src="\images\Java\第五章\2.jpg" style="zoom:50%;"></p><p><strong>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有些时候是可以避免的。</strong></p><p><strong>面向对象语言异常处理思想</strong>：</p><ul><li>将程序正常代码和错误处理代码分开。</li><li>使程序具有处理运行错误的能力。</li></ul><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>错误（Error）指程序运行时遇到的<strong>硬件</strong>、<strong>操作系统</strong>、 <strong>虚拟机</strong>的错误。 Error错误类</p><p><strong>Java程序不能处理错误，只能依靠外界干预。</strong></p><p><img src="\images\Java\第五章\1.jpg" style="zoom:50%;"></p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常（Exception）指在硬件、操作系统、虚拟 机正常时，<strong>程序遇到的运行错（语义错)</strong>。</p><p><img src="\images\Java\第五章\3.jpg" style="zoom:50%;"></p><p><strong>异常处理方式：</strong></p><ul><li>程序应避免而不捕获的异常，运行异常 ，除数为0、数组下标越界等</li><li>必须捕获的异常。数值格式异常，如果没有捕获，由Java虚拟机处理。文件不存在、网络连接中断、数据库连接中断等，必须捕获，否则编译不能通过。</li></ul><h1 id="异常处理措施"><a href="#异常处理措施" class="headerlink" title="异常处理措施"></a>异常处理措施</h1><h2 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>； <span class="comment">//存在潜在异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (异常类 异常对象)</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">2</span>； <span class="comment">//捕获到异常并进行处理的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">3</span>；<span class="comment">//最后必须执行的代码，无论是否捕获到异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;123a&quot;</span>; </span><br><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i = Integer.parseInt(str); <span class="comment">//调用声明抛出异常方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(NumberFormatException ex) <span class="comment">//捕获异常对象</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(str+<span class="string">&quot;字符串不能转换为整数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception ex) <span class="comment">//捕获所有异常对象</span></span><br><span class="line">&#123;</span><br><span class="line">    ex.printStackTrace(); <span class="comment">//显示异常栈跟踪信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try语句执行流程"><a href="#try语句执行流程" class="headerlink" title="try语句执行流程"></a>try语句执行流程</h2>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java/">Java</category>
      
      
      
      <comments>http://example.com/2021/11/12/Java/%E7%AC%AC%E4%BA%94%E7%AB%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>接口</title>
      <link>http://example.com/2021/11/10/Java/%E7%AC%AC%E5%9B%9B%E7%AB%A0/</link>
      <guid>http://example.com/2021/11/10/Java/%E7%AC%AC%E5%9B%9B%E7%AB%A0/</guid>
      <pubDate>Wed, 10 Nov 2021 14:45:25 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h1&gt;&lt;p&gt;接口中常量定义时，可以不写public static final，缺省有。接口中方法定义 时，可以不写public abstract，缺省有</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口中常量定义时，可以不写public static final，缺省有。接口中方法定义 时，可以不写public abstract，缺省有。接口只定义不变的内容（常量和抽象方法）</p><p>一个类可以实现多个接口（implements），接口不能new一个对象，但是是引用数据类型，并且可用于声明引用变量类型。接口可以继承另一个接口（extends），而且支持多继承。一个类实现一个接口，必须实现之中所有方法，并且方法只能是 public的</p><p><strong>定义方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="class"><span class="keyword">interface</span> 接口 [<span class="keyword">extends</span> 父接口列表 ]</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] 数据类型 成员变量=常量值;</span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">abstract</span>] 返回值类型 成员方法[(参数列表)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口声明的引用类型变量只能调用接口中定义过的方法。</strong>比如下面的ar和vol，只能调用相应的area方法和volume方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ClosedFigure fig = <span class="keyword">new</span> Ellipse(point,<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//父类对象fig引用椭圆子类实例</span></span><br><span class="line">Area ar = fig; <span class="comment">//Area接口对象ar引用实现Area接口的</span></span><br><span class="line">ClosedFigure类的Ellipse子类实例</span><br><span class="line">ar.area() <span class="comment">//运行时多态</span></span><br><span class="line">Cylinder cylinder = <span class="keyword">new</span> Cylinder(fig,<span class="number">10</span>); <span class="comment">//椭圆柱</span></span><br><span class="line">ar = cylinder; <span class="comment">//ar引用实现Area接口的Cylinder类的实例</span></span><br><span class="line">Volume vol = cylinder; <span class="comment">//Volume接口对象vol引用实现Volume接口的Cylinder类的实例</span></span><br><span class="line">ar.area() <span class="comment">//运行时多态</span></span><br><span class="line">vol.volume()</span><br></pre></td></tr></table></figure><p><img src="\imazges\Java\第四章\1.jpg" style="zoom:67%;"></p><h1 id="内部类和内部接口"><a href="#内部类和内部接口" class="headerlink" title="内部类和内部接口"></a>内部类和内部接口</h1><ul><li>内嵌类型不能与外层类型同名。</li><li>内部类中可以声明成员变量和成员方法。</li><li>内部类可以继承父类或实现接口。</li><li>可以声明内部类为抽象类，该抽象类必 须被其他内部类继承；内部接口必须被 其他内部类实现。</li><li>使用点运算符“ . ”引用内嵌类型： 外层类型.内嵌类型</li><li>内嵌类型具有类中成员的4种访问控制权限。当内 部类可被访问时，才能考虑内部类中成员的访问控 制权限</li><li>内嵌类型与其外层类型彼此信任，能访问对方的所 有成员。</li><li>在实例内部类中，使用以下格式引用或调用外部类当前实例的成员变量或实例 成员方法</li><li>内部接口总是静态的。内部类可声明是静态的或实 例的，静态内部类能够声明静态成员，但不能引用 外部类的实例成员；实例内部类不能声明静态成员</li></ul><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型声明"><a href="#泛型声明" class="headerlink" title="泛型声明"></a>泛型声明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类&lt;类型参数列表&gt; [<span class="keyword">extends</span> 父类] [<span class="keyword">implements</span> 接口列表]</span></span><br><span class="line"><span class="class">[<span class="title">public</span>] <span class="title">interface</span> 接口&lt;类型参数列表&gt; [<span class="keyword">extends</span> 父接口列表]</span></span><br><span class="line"><span class="class">[<span class="title">public</span>] [<span class="title">static</span>] &lt;类型参数列表&gt; 返回值类型 方法([参数列表]) [<span class="title">throws</span> 异常类列表]</span></span><br><span class="line"><span class="class">[修饰符] <span class="title">class</span> 类&lt;类型参数列表&gt;[<span class="keyword">extends</span> 父类] [<span class="keyword">implements</span> 接口列表]</span></span><br><span class="line"><span class="class">[<span class="title">public</span>] <span class="title">interface</span> 接口&lt;类型参数列表&gt;[<span class="keyword">extends</span> 父接口列表]</span></span><br><span class="line"><span class="class">[<span class="title">public</span>] [<span class="title">static</span>] &lt;类型参数列表&gt; 返回值类型 方法([参数列表]) [<span class="title">throws</span> 异常类列表]</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java/">Java</category>
      
      
      
      <comments>http://example.com/2021/11/10/Java/%E7%AC%AC%E5%9B%9B%E7%AB%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>类</title>
      <link>http://example.com/2021/11/08/Java/%E7%AC%AC%E4%B8%89%E7%AB%A0/</link>
      <guid>http://example.com/2021/11/08/Java/%E7%AC%AC%E4%B8%89%E7%AB%A0/</guid>
      <pubDate>Mon, 08 Nov 2021 11:41:16 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h1&gt;&lt;p&gt;类相当于是对象的模板，可以认为对象就是实例。&lt;/p&gt;
&lt;p&gt;也可以像下面这样理解？&lt;/p&gt;
&lt;figure class=&quot;h</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类相当于是对象的模板，可以认为对象就是实例。</p><p>也可以像下面这样理解？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类 对象;<span class="comment">//这里的相当于对象</span></span><br><span class="line">对象 = <span class="keyword">new</span> 类的构造方法([参数列表]);<span class="comment">//分配了内存空间以后才是一个实例</span></span><br></pre></td></tr></table></figure><p><strong>类（class）</strong>是既包括数据又包括作用于数据的一组操作的 封装体。类可以看成是一类相似对象的模板！类具有封装性、 继承性、多态性和抽象性。</p><p><strong>对象（object）</strong>是类的具体<strong>实例（instance）</strong>。Java中， 万事万物皆对象！！！Java中通过引用操作对象！引用就 是指向对象的内存中地址！！</p><h1 id="类的变量和方法"><a href="#类的变量和方法" class="headerlink" title="类的变量和方法"></a>类的变量和方法</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>在类中，用static声明的成员变量为静态成员变量，它为该类的公用变量、属于类，被 该类的所有实例共享，在类被载入时被显示初始化；对于该类的所有对象来说，static成员变量只有一份；可以使用 “对象.类属性”来调用，不过，一般都是用”类名.类属性”；static变量置于方法区中）。<strong>局部变量</strong>使用前必须要<strong>先赋值</strong>、而<strong>实例变量</strong>则有<strong>缺省初值</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">22</span>;<span class="comment">//类变量</span></span><br><span class="line">    String name = <span class="string">&quot;张三&quot;</span>;<span class="comment">//实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>局部变量：</strong></p><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li><strong>访问修饰符不能用于局部变量；</strong></li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul><p><strong>实例变量：</strong></p><ul><li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>访问修饰符可以修饰实例变量；</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li></ul><p><strong>类变量(静态变量)：</strong></p><ul><li>类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。</li><li>无论一个类创建了多少个对象，<strong>类只拥有类变量的一份拷贝。</strong></li><li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li><li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li><li>静态变量在程序开始时创建，在程序结束时销毁。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li><li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li><li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>定义格式：<code>[修饰符] 方法返回值类型 方法名(形参列表) &#123; // n条语句 &#125;</code></p><h1 id="类的封装性"><a href="#类的封装性" class="headerlink" title="类的封装性"></a>类的封装性</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法，又称为<strong>构造器Constructor</strong>，用于构造该类的实例。<strong>返回值类型</strong>为该类本身。</p><p>如果我们没有定义构造器，系统自动会定义一个无参的构造器，如果已定义则编译器不会添加；构造器的方法名必须和类名一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明及调用构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> </span></span><br><span class="line"><span class="class"></span>&#123; <span class="function"><span class="keyword">public</span> <span class="title">MyDate</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        year = y;</span><br><span class="line">        month = m;</span><br><span class="line">        day = d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyDate d = <span class="keyword">new</span> MyDate(<span class="number">2009</span>,<span class="number">7</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyDate</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>方法的<strong>重载</strong>overload。方法的重载是指一个类中可以定义有相同的名字， 但参数不同的多个方法。调用时，会根据不同的参数列表选择对应的方法。</p><p><strong>重载</strong>：同一个类，同一个方法名，不同的参数列表（类型、个数、顺序不同）</p><ul><li><p>只有返回值不同不构成方法的重载。 </p></li><li><p>只有形参的名称不同，不构成方法的重载。</p></li><li><p>构造方法与普通方法一样也可以重载。</p></li></ul><h2 id="对象的引用和运算"><a href="#对象的引用和运算" class="headerlink" title="对象的引用和运算"></a>对象的引用和运算</h2><h3 id="this引用"><a href="#this引用" class="headerlink" title="this引用"></a>this引用</h3><ul><li>指代对象本身</li><li>访问本类的成员变量和成员方法</li><li>调用<strong>本类重载的构造方法</strong></li><li>普通方法中，this总是指向调用该方法的对象；</li><li>构造方法中，this总是指向正要初始化的对象；</li><li>this<strong>不能用于static</strong>方法；</li><li>可以在一个构造方法中通过this调用其它构造方法，且<strong>必须是构造方法中的第一条语句</strong>。</li><li>this只能用在方法中，其的本质是“<strong>调用该方法的创建好的对象的地址</strong>”。由于在 构造方法调用时，对象已经创建。因此，在构造方法中也可以使用this代表“当前 对象”。</li></ul><h3 id="instanceof运算"><a href="#instanceof运算" class="headerlink" title="instanceof运算"></a>instanceof运算</h3><p>instanceof 运算符 用于：判断 该运算符前面引用类型变量指向的对象是否是后面类，或者其子类、接口实现类创建的对象。如果是则返回true，否则返回false</p><h2 id="隐藏-封装"><a href="#隐藏-封装" class="headerlink" title="隐藏/封装"></a>隐藏/封装</h2><p><strong>类的访问权限：</strong>public和缺省</p><p><strong>类中成员的访问权限：</strong></p><div class="table-container"><table><thead><tr><th>权限修饰符</th><th>同一类</th><th>同一包</th><th>不同包的子类</th><th>所有类</th></tr></thead><tbody><tr><td>public(公有)</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected(受保护的)</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>缺省</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>private(私有)</td><td>√</td><td></td><td></td></tr></tbody></table></div><p><strong>静态成员变量：</strong>在类中，用static声明的成员变量为静态成员变量，或叫做类属 性、类变量。它为该类的公用变量，属于类，被该类的所有实例共享（只此一 份），在类被载入时被显式初始化。可以使用“对象.类属性”来调用，不过一般 都使用“类名.类属性”。static变量置于方法区</p><p><strong>静态方法：</strong></p><ul><li><p>静态方法不需要通过它所属的类的任何实例就可以被调用，因此在静态方法中不能使用 this 关键字，也不能直接访问所属类的实例变量和实例方法，但是可以直接访问所属类的静态变量和静态方法。另外，和 this  关键字一样，super 关键字也与类的特定实例相关，所以在静态方法中也不能使用 super 关键字。父类中是静态方法，</p></li><li><p>子类中不能覆盖为非静态方法；在符合覆盖规则的前提下， 在父子类中，父类中的静态方法可以被子类中的静态方法覆盖，但无多态</p></li><li>父子类中，静态方法只能被静态方法覆盖，父子类中，非静态方法只能被非静态方法覆盖</li></ul><p><strong>静态初始化块 static {}：</strong>如果希望加载后，对整个类进行某些初始化操作，可 以使用static初始化，</p><ul><li>是在类初始化时执行，不是在创建对象时执行。</li><li>静态初始化块中不能访问非static成员变量。</li><li>执行顺序：上溯到Object类，先执行Object的静态初始化块，再向下执行子 类的静态初始化块，直到我们的类的静态初始化块为止。</li></ul><h1 id="类的继承性"><a href="#类的继承性" class="headerlink" title="类的继承性"></a>类的继承性</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>基于一个已存在的类，创建一个新的类。已存在的类即父类，新的类即子类，继承就是子类继承并拥有父类的属性和方法，同时，子类还有拥有父类所不具有的属性和方法。</p><p>父类，也称为基类、超类（superclass）；子类，也称为派生类。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul><li>子类继承父类的成员变量</li><li>子类继承父类除构造方法以外的成员方法</li><li>子类不能继承父类的构造方法</li><li>子类可以增加成员，可以重定义从父类继承来的 成员，但不能删除它们。</li></ul><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Object</span><span class="params">()</span> <span class="comment">//构造方法</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> <span class="comment">//描述对象</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//比较对象相等</span></span></span><br><span class="line"><span class="function">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>Java中的类都是Object的子类</p><h2 id="子类对父类成员的访问权限"><a href="#子类对父类成员的访问权限" class="headerlink" title="子类对父类成员的访问权限"></a>子类对父类成员的访问权限</h2><ul><li>子类不能访问父类的私有成员（private）</li><li>子类能够访问父类的公有成员（public）和保护成员（protected）。</li><li>子类对父类的缺省权限成员的访问控制，以包为界分两种情况，可以访问当前包中成员</li></ul><h2 id="子类的构造方法"><a href="#子类的构造方法" class="headerlink" title="子类的构造方法"></a>子类的构造方法</h2><p>使用super()调用父类构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>([参数列表])</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, MyDate birthday, String spec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, birthday); <span class="comment">//调用父类同参数的构造方法</span></span><br><span class="line">    <span class="keyword">this</span>.speciality = spec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认执行super()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> <span class="comment">//Java提供的默认构造方法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">//调用父类构造方法Person()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="super引用"><a href="#super引用" class="headerlink" title="super引用"></a>super引用</h2><ul><li>调用父类的构造方法。<code>super([参数列表])</code></li><li>引用父类同名成员。<code>super.成员变量</code>，<code>super.成员方法([参数列表])</code></li><li>super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方 法或属性。</li></ul><h1 id="类的抽象性"><a href="#类的抽象性" class="headerlink" title="类的抽象性"></a>类的抽象性</h1><ul><li>有抽象方法的类只能定义成抽象类。</li><li>抽象类不能实例化，即不能用new来实例化抽象类。</li><li>抽象类只能用来继承。</li><li>抽象类可以包含属性、方法、构造方法（抽象类除了抽象方法，也可以定义普通方法、 构造方法和普通属性）。但是构造方法不能用来new实例，只能用来被子类调用。</li><li>抽象方法只有方法的声明，没有方法体（即{}和里面的代码），其必须被子类实现 （这也是抽象方法的设计初衷，提供规范，要求各子类实现规范）</li><li>抽象类用于设计和实现的分离，但是这种分离不够彻底。</li><li>一个抽象类可以继承另一个抽象类</li><li>有抽象方法的类一定是抽象类，但是抽象类中不一定都是抽象方法，也可以全部都是具体方法</li></ul><p><strong>特点：</strong></p><ul><li>构造方法、静态成员方法不能被声明为抽象方法。</li><li>一个非抽象类必须实现从父类继承来的所有抽象方法</li><li>不能创建抽象类的实例。</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java/">Java</category>
      
      
      
      <comments>http://example.com/2021/11/08/Java/%E7%AC%AC%E4%B8%89%E7%AB%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>parameter,defparame,`define,localparam四者区别</title>
      <link>http://example.com/2021/11/07/FPGA/parameter/</link>
      <guid>http://example.com/2021/11/07/FPGA/parameter/</guid>
      <pubDate>Sun, 07 Nov 2021 09:02:40 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;figure class=&quot;highlight verilog&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span>:    作用 -&gt; 常用于定义常量可以跨模块、跨文件;</span></span><br><span class="line">            范围 -&gt; 整个工程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span>:  作用 -&gt; 常用于模块间参数传递;</span><br><span class="line">            范围 -&gt; 本<span class="keyword">module</span>内有效的定义;</span><br><span class="line"></span><br><span class="line"><span class="keyword">localparam</span>: 作用 -&gt; 常用于状态机的参数定义;</span><br><span class="line">            范围 -&gt; 本<span class="keyword">module</span>内有效的定义，不可用于参数传递;</span><br><span class="line"><span class="keyword">localparam</span> cannot be used <span class="keyword">within</span> the <span class="keyword">module</span> port <span class="keyword">parameter</span> list.</span><br></pre></td></tr></table></figure><h2 id="Parameter"><a href="#Parameter" class="headerlink" title="Parameter"></a>Parameter</h2><p>可以放在模块头上也可以放在模块的内部，他可以通过defparameter的方式或者模块实例化的时候进行重写。</p><p><strong>Example：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo</span><br><span class="line">#(<span class="keyword">parameter</span> MSB=<span class="number">3</span>, LSB=<span class="number">0</span>, DEPTH=<span class="number">4</span>)<span class="comment">//可以被重写</span></span><br><span class="line"> (port_list );</span><br><span class="line"> item;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo</span><br><span class="line"> (port_list );</span><br><span class="line"> <span class="keyword">parameter</span> MSB=<span class="number">3</span>, LSB=<span class="number">0</span>, DEPTH=<span class="number">4</span><span class="comment">//可以被重写</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>一旦有模块参数被写在模块头部，则出现在模块内部的模块参数被视为本地参数，不能被重写。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo</span><br><span class="line"> #(<span class="keyword">parameter</span> MSB=<span class="number">3</span>, LSB=<span class="number">0</span>)<span class="comment">//可以被重写</span></span><br><span class="line"> (port_list );</span><br><span class="line"><span class="keyword">parameter</span> DEPTH=<span class="number">4</span>; <span class="comment">//不能被重写</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>在上层模块对参数重写的方式如下:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)F1<span class="variable">.MSB</span>=<span class="number">4</span>;F1<span class="variable">.LSB</span>=<span class="number">2</span>;fifo F1;</span><br><span class="line"><span class="number">2</span>) fifo <span class="variable">#(4,2) F1(port_list)</span>;</span><br><span class="line"><span class="number">3</span>) fifo <span class="variable">#(.LSB(2), .MSB(4)) fifo(port_list)</span>;</span><br></pre></td></tr></table></figure><h2 id="defparam修改参数"><a href="#defparam修改参数" class="headerlink" title="defparam修改参数"></a>defparam修改参数</h2><p>当一个模块引用另外一个模块时，高层模块可以改变低层模块用parameter定义的参数值。例子代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Top(...);<span class="comment">//这是一个顶层模块</span></span><br><span class="line">    <span class="keyword">defparam</span>    U_D1<span class="variable">.Width</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">defparam</span>    U_D1<span class="variable">.Polarity</span> = <span class="number">0</span>;<span class="comment">//使得U_D1的Width = 4， Polarity = 0；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defparam</span>    U_D2<span class="variable">.Width</span> = <span class="number">5</span>;<span class="comment">//使得U_D2的Width = 5，Polarity 不变，即为1；</span></span><br><span class="line">    Decode U_D1();</span><br><span class="line">    Decode U_D2(); </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Decode(A,F);    <span class="comment">//这是一个子模块</span></span><br><span class="line">    <span class="keyword">parameter</span> Width = <span class="number">1</span>, Polarity = <span class="number">1</span>;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>也可以模块实例化的时候进行修改，代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Top(...);<span class="comment">//这是一个顶层模块</span></span><br><span class="line">    Decode <span class="variable">#(4,0) U_D1()</span>; <span class="comment">//使得Width = 4， Polarity = 0；</span></span><br><span class="line">    Decode <span class="variable">#(5) U_D2()</span>; <span class="comment">//使得 Width = 5，Polarity 不变，即为1；</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Decode(A,F);    <span class="comment">//这是一个子模块</span></span><br><span class="line">    <span class="keyword">parameter</span> Width = <span class="number">1</span>, Polarity = <span class="number">1</span>;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="define"><a href="#define" class="headerlink" title="`define"></a>`define</h2><p><strong>概念：</strong>可以跨模块的定义，写在模块名称上面，在整个设计工程都有效。一旦define指令被编译，其在整个编译过程中都有效。例如，通<br>过另一个文件中的define指令，定义的常量可以被其他文件调用,直到遇到undef；</p><p><strong>举例：</strong>定义 define UART_CNT 10’d1024.使用UART_CNT</p><h2 id="localparam："><a href="#localparam：" class="headerlink" title="localparam："></a>localparam：</h2><p><strong>概念：</strong>本module内有效的定义，不可用于参数传递；localparamcannot be used within the module port parameter list.一般情况下，状态机的参数都是用localparam的。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/FPGA/">FPGA</category>
      
      
      
      <comments>http://example.com/2021/11/07/FPGA/parameter/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>时域卷积频域相乘</title>
      <link>http://example.com/2021/11/07/%E4%BF%A1%E5%8F%B7/%E6%97%B6%E5%9F%9F%E5%8D%B7%E7%A7%AF%E9%A2%91%E5%9F%9F%E7%9B%B8%E4%B9%98/</link>
      <guid>http://example.com/2021/11/07/%E4%BF%A1%E5%8F%B7/%E6%97%B6%E5%9F%9F%E5%8D%B7%E7%A7%AF%E9%A2%91%E5%9F%9F%E7%9B%B8%E4%B9%98/</guid>
      <pubDate>Sun, 07 Nov 2021 07:33:57 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;傅里叶级数（时域卷积频域相乘）&lt;/p&gt;
&lt;p&gt;​    一般教科书都是选择理论证明，但是如何直观去理解呢。我们知道一个信号可以傅里叶变换分解后然后变成很多个不同频率正弦信号。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f(t)=\</description>
        
      
      
      
      <content:encoded><![CDATA[<p>傅里叶级数（时域卷积频域相乘）</p><p>​    一般教科书都是选择理论证明，但是如何直观去理解呢。我们知道一个信号可以傅里叶变换分解后然后变成很多个不同频率正弦信号。</p><script type="math/tex; mode=display">f(t)=\frac {a_0} {2} +\sum_{n=1}^{+\infty}a_ncos(n\omega_0 t)+b_nsin(n\omega_0 t)\\a_0 =\frac{1}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}}f(t)dt \ \ \ \ \ a_n = \frac{2}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(t)cos(n\omega_0t)dt\ \ \ \ \b_n = \frac{2}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(t)sin(n\omega_0t)dt</script><p>我们将两个信号去卷积，正弦信号卷积分配，不同频率的正弦信号卷积后为0（“正交”）.</p><p>那么就是相同频率的正弦信号相卷积，频率不变，辐值相乘。</p><p>而频域就是不同频率分量的相对大小，因此这在频域上就表现为相乘。</p><p>​    从知乎上看到的，写的很好，分享一下</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E4%BF%A1%E5%8F%B7/">信号</category>
      
      
      
      <comments>http://example.com/2021/11/07/%E4%BF%A1%E5%8F%B7/%E6%97%B6%E5%9F%9F%E5%8D%B7%E7%A7%AF%E9%A2%91%E5%9F%9F%E7%9B%B8%E4%B9%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Testbench文件编写方法</title>
      <link>http://example.com/2021/11/07/FPGA/Testbench%E6%96%87%E4%BB%B6%E8%AF%BB%E6%B3%95%E5%92%8C%E5%86%99%E6%B3%95/</link>
      <guid>http://example.com/2021/11/07/FPGA/Testbench%E6%96%87%E4%BB%B6%E8%AF%BB%E6%B3%95%E5%92%8C%E5%86%99%E6%B3%95/</guid>
      <pubDate>Sun, 07 Nov 2021 07:22:45 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;转载：&lt;a href=&quot;https://blog.csdn.net/weixin_46423500/article/details/113264878&quot;&gt;https://blog.csdn.net/weixin_46423500/article/details/113264</description>
        
      
      
      
      <content:encoded><![CDATA[<p>转载：<a href="https://blog.csdn.net/weixin_46423500/article/details/113264878">https://blog.csdn.net/weixin_46423500/article/details/113264878</a></p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>testbench文件基本结构：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 仿真单位/仿真精度</span></span><br><span class="line"><span class="keyword">module</span> test_bench();</span><br><span class="line"><span class="comment">//通常 testbench没有输入与输出端口</span></span><br><span class="line">信号或变量定义声明</span><br><span class="line">使用<span class="keyword">initial</span>或<span class="keyword">always</span>语句产生激励波形</span><br><span class="line">例化设计模块</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="声明仿真精度和仿真单位"><a href="#声明仿真精度和仿真单位" class="headerlink" title="声明仿真精度和仿真单位"></a>声明仿真精度和仿真单位</h3><p>/#(延时时间)，#(10ns)代表延时10ns</p><p>仿真精度就是说最低的延时精度，比如说<code>`timescale 1ns/1ns</code>，延时精度只能达到1ns</p><p>如果想要延时10.001ns，就要把仿真精度改成1ps(1ns = 1000ps)。</p><h3 id="定义模块名"><a href="#定义模块名" class="headerlink" title="定义模块名"></a>定义模块名</h3><p><code>module flow_led_tb();</code></p><p>模块名的命名方式一般在被测模块名后面加上“ _ tb”，或者在被测模块名前面加上“tb_”，表示为哪个模块提供激励测试文件，通常激励文件不需要定义输入和输出端口。</p><h3 id="信号或常量定义"><a href="#信号或常量定义" class="headerlink" title="信号或常量定义"></a>信号或常量定义</h3><p><strong>常量：</strong></p><p> 代码中定义的常量有时需要频繁的修改，为了方便修改，可以把常量定义成参数的形式，定义参数的关键字为parameter，代码如下：</p><p><code>parameter T = 20;</code></p><p><strong>变量：</strong></p><p>Verilog代码中，常用声明信号或变量的关键字为reg和wire，在initial语句或者always语句中使用的变量定义成reg类型，在assign语句或者用于连接被例化模块名的信号定义成wire类型，声明方法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reg define</span></span><br><span class="line"><span class="keyword">reg</span> sys_clk; <span class="comment">// 时钟信号</span></span><br><span class="line"><span class="keyword">reg</span> sys_rst_n; <span class="comment">// 复位信号</span></span><br><span class="line"><span class="comment">//wire define</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] led;</span><br></pre></td></tr></table></figure><p><strong>使用initial或always语句产生激励波形：</strong><br> 产生时钟激励。代码表示每10ns（假设仿真单位是1ns），sys_clk的电平状态翻转一次，由于一个完整的时钟周期包括一个高电平和一个低电平，因此sys_clk的时钟周期为20ns，占空比为50%。代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> #<span class="number">10</span> sys_clk = ~sys_clk;</span><br></pre></td></tr></table></figure><p>如果要生成其它占空比时钟的话，代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">#<span class="number">6</span> sys_clk = <span class="number">0</span>; #<span class="number">4</span> sys_clk = <span class="number">1</span>; <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在always语句中设置了sys_clk的时钟周期，并没有设置初始值，因此sys_clk需要在initial语句中进行初始化。代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"> sys_clk = <span class="number">1&#x27;b0</span>; <span class="comment">// 时钟初始值</span></span><br><span class="line">sys_rst_n = <span class="number">1&#x27;b0</span>; <span class="comment">// 复位初始值</span></span><br><span class="line"> #<span class="number">20</span> sys_rst_n = <span class="number">1&#x27;b1</span>; <span class="comment">// 在第21ns的时候复位信号信号拉高</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="例化设计模块"><a href="#例化设计模块" class="headerlink" title="例化设计模块"></a>例化设计模块</h3><p>例化的设计模块是指被测模块，例化被测模块的目的是把被测模块和激励模块实例化起来，并且把被测模块的端口与激励模块的端口进行相应的连接，使得激励可以输入到被测模块。如果被测模块是由多个模块组成的，激励模块中只需要例化多个模块的顶层模块，代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow_led u0_flow_led (</span><br><span class="line"> <span class="variable">.sys_clk</span> (sys_clk ),</span><br><span class="line"> <span class="variable">.sys_rst_n</span> (sys_rst_n),</span><br><span class="line"> <span class="variable">.led</span> (led )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="完整文件"><a href="#完整文件" class="headerlink" title="完整文件"></a>完整文件</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">`<span class="meta-keyword">timescale</span> 1ns/1ns // 定义仿真时间单位1ns和仿真时间精度为1ns</span></span><br><span class="line"> <span class="keyword">module</span> flow_led_tb(); <span class="comment">// 测试模块</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//parameter define</span></span><br><span class="line"><span class="keyword">parameter</span> T = <span class="number">20</span>; <span class="comment">// 时钟周期为20ns</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//reg define</span></span><br><span class="line"><span class="keyword">reg</span> sys_clk; <span class="comment">// 时钟信号</span></span><br><span class="line"> <span class="keyword">reg</span> sys_rst_n; <span class="comment">// 复位信号</span></span><br><span class="line"><span class="comment">//wire define</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] led;</span><br><span class="line"><span class="comment">//给输入信号初始值</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">sys_clk = <span class="number">1&#x27;b0</span>;</span><br><span class="line">sys_rst_n = <span class="number">1&#x27;b0</span>; <span class="comment">// 复位</span></span><br><span class="line"><span class="variable">#(T+1)</span> sys_rst_n = <span class="number">1&#x27;b1</span>; <span class="comment">// 在第21ns的时候复位信号信号拉高</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//50Mhz的时钟，周期则为1/50Mhz=20ns,所以每10ns，电平取反一次</span></span><br><span class="line"><span class="keyword">always</span> <span class="variable">#(T/2)</span> sys_clk = ~sys_clk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例化flow_led模块</span></span><br><span class="line">flow_led u0_flow_led (</span><br><span class="line"><span class="variable">.sys_clk</span> (sys_clk ),</span><br><span class="line"><span class="variable">.sys_rst_n</span> (sys_rst_n),</span><br><span class="line"><span class="variable">.led</span> (led )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/FPGA/">FPGA</category>
      
      
      
      <comments>http://example.com/2021/11/07/FPGA/Testbench%E6%96%87%E4%BB%B6%E8%AF%BB%E6%B3%95%E5%92%8C%E5%86%99%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
